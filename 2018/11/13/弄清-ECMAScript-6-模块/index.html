<!DOCTYPE html><html class="theme-next gemini use-motion" lang="ZH | EN"><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="AKuwh4i11uWg0wOl_cM7AI_dHqOHOLKYfCxKc8Lfv6E"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="FE,ES6,"><link rel="alternate" href="/atom.xml" title="Kinboy's note" type="application/atom+xml"><meta name="description" content="原文: ECMAScript 6 modules: the final syntax 1. JavaScript 的模块系统现状JavaScript 没有内建的模块系统，但是社区创造了很多给力的解决方案。 两种最重要（不幸的是互不兼容）的标准是:  CommonJS Modules: 这个标准的主要 实现是在Node.js中（Node.js 模块有一些特性领先于 CommonJS)。 特性：  语"><meta name="keywords" content="FE,ES6"><meta property="og:type" content="article"><meta property="og:title" content="弄清 ECMAScript 6 模块"><meta property="og:url" content="http://kinboyw.github.io/2018/11/13/弄清-ECMAScript-6-模块/index.html"><meta property="og:site_name" content="Kinboy&#39;s note"><meta property="og:description" content="原文: ECMAScript 6 modules: the final syntax 1. JavaScript 的模块系统现状JavaScript 没有内建的模块系统，但是社区创造了很多给力的解决方案。 两种最重要（不幸的是互不兼容）的标准是:  CommonJS Modules: 这个标准的主要 实现是在Node.js中（Node.js 模块有一些特性领先于 CommonJS)。 特性：  语"><meta property="og:locale" content="ZH | EN"><meta property="og:updated_time" content="2019-07-15T10:05:10.400Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="弄清 ECMAScript 6 模块"><meta name="twitter:description" content="原文: ECMAScript 6 modules: the final syntax 1. JavaScript 的模块系统现状JavaScript 没有内建的模块系统，但是社区创造了很多给力的解决方案。 两种最重要（不幸的是互不兼容）的标准是:  CommonJS Modules: 这个标准的主要 实现是在Node.js中（Node.js 模块有一些特性领先于 CommonJS)。 特性：  语"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"I didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://kinboyw.github.io/2018/11/13/弄清-ECMAScript-6-模块/"><title>弄清 ECMAScript 6 模块 | Kinboy's note</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9c2b9e915e6bb8ec323a2f98c0c98d8";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><body itemscope itemtype="http://schema.org/WebPage" lang="ZH | EN"><div class="container sidebar-position-left page-post-detail"><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"></span><span class="site-title">Kinboy's note</span><span class="logo-line-after"></span></a></div><h1 class="site-subtitle" itemprop="description">前端漫记</h1></div><div class="site-nav-toggle"><button></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><br>Home</a><li class="menu-item menu-item-about"><a href="/rscard/" rel="section"><br>About</a><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><br>Tags</a><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><br>Categories</a><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><br>Archives</a><li class="menu-item menu-item-top"><a href="/top/" rel="section"><br>Top</a><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><br>Search</a></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"></span><span class="popup-btn-close"></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-categories" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://kinboyw.github.io/2018/11/13/弄清-ECMAScript-6-模块/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="kinboy"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Kinboy's note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">弄清 ECMAScript 6 模块</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"></span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-13T15:56:58+08:00">2018-11-13</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/FE/" itemprop="url" rel="index"><span itemprop="name">FE</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/FE/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"></span><a href="/2018/11/13/弄清-ECMAScript-6-模块/#comments" itemprop="discussionUrl"></a></span><div class="post-wordcount"><span class="post-meta-item-icon"></span><span class="post-meta-item-text">Words count in article&#58;</span> <span title="Words count in article">4.7k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"></span> <span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">18</span></div></div></header><div class="post-body" itemprop="articleBody"><p>原文: <a href="http://2ality.com/2014/09/es6-modules-final.html" target="_blank" rel="noopener">ECMAScript 6 modules: the final syntax</a><h3 id="1-JavaScript-的模块系统现状">1. JavaScript 的模块系统现状</h3><p>JavaScript 没有内建的模块系统，但是社区创造了很多给力的解决方案。 两种最重要（不幸的是互不兼容）的标准是:<ul><li><p><strong>CommonJS Modules</strong>: 这个标准的主要 实现是在Node.js中（Node.js 模块有一些特性领先于 CommonJS)。<p>特性：<ul><li>语法紧凑<li>设计用于同步加载<li>主要应用于服务器端</ul><li><p><strong>Asynchronous Module Definition (AMD):</strong> 这个标准的主要实现是 RequireJS。<p>特性：<ul><li><p>语法稍微复杂，使AMD能够在没有 <code>eval()</code>（或者无须编译）的情况下工作。<li><p>设计用于异步加载<li><p>主要用于浏览器端</ul></ul><p>上面只是对当前状况的简单介绍，如果想要详细了解，可以看看 Addy Osmani 写的 “<a href="https://addyosmani.com/writing-modular-js/" target="_blank" rel="noopener">Writing Modular JavaScript With AMD, CommonJS &amp; ES Harmony</a>”</p><h3 id="2-ECMAScript-6-模块">2. ECMAScript 6 模块</h3><p>ECMAScript 6（后面简称ES6） 模块的设计目标是要创造一种让 CommonJS 和 AMD 的用户都能愉快使用的模块系统：<ul><li><p>类似 CommonJS ，ES6 模块也有紧凑的语法，偏向于单个导出，支持循环依赖。<li><p>类似 AMD，ES6 模块直接支持异步加载和可配置模块加载。</ul><p>内置于语言中，使得 ES6 模块超越 CommonJS 和 AMD （后面会详细说明）:<ul><li>语法甚至比 CommonJS 更加紧凑<li>结构可以静态分析（用于静态检查，优化等）<li>支持循环引用这一点要优于 CommonJS</ul><p>ES6 模块分为两个部分:<ul><li>声明语法（用于导入和导出）<li>可编程的加载器 API：配置模块的加载方式以及按条件模块加载</ul><h3 id="3-ES6-模块语法概述">3. ES6 模块语法概述</h3><p>有两种导出方式：命名导出（一对多模块）和默认导出（一对一模块）。<h4 id="3-1-命名导出-（一对多模块）">3.1 命名导出 （一对多模块）</h4><p>一个模块可以通过在声明前添加关键字 <code>export</code> 来导出多个东西。这些导出按名称区分，成为命名导出。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</span><br><span class="line">&#125;</span><br></pre></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">import</span> &#123; square, diag &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></span><br><span class="line"><span class="built_in">console</span>.log(diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br></pre></table></figure><p>也有其他的方式声明命名导出（后面详细介绍），但是我发现这个非常方便：直接在js文件里写好代码，然后在你想导出的每一个东西的定义前加上一个 <code>export</code> 关键字。<p>你也可以引入整个模块，然后通过属性表达式引用其命名导出：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> lib <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(lib.square(<span class="number">11</span>)); <span class="comment">// 121</span></span><br><span class="line"><span class="built_in">console</span>.log(lib.diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br></pre></table></figure><p><strong>CommonJS 语法中相同的代码：</strong>曾经有段时间，我尝试过用一些聪明的办法，来减少 Node.js 中模块导出的冗余。现在我更喜欢下面的简单但略显冗长的风格:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">var</span> sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sqrt: sqrt,</span><br><span class="line">    square: square,</span><br><span class="line">    diag: diag,</span><br><span class="line">&#125;;</span><br></pre></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="built_in">require</span>(<span class="string">'lib'</span>).square;</span><br><span class="line"><span class="keyword">var</span> diag = <span class="built_in">require</span>(<span class="string">'lib'</span>).diag;</span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></span><br><span class="line"><span class="built_in">console</span>.log(diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br></pre></table></figure><h4 id="3-2-默认导出-（一对一模块）">3.2 默认导出 （一对一模块）</h4><p>导出单一值的模块在 Node.js 社区大受欢迎。但是在前端开发中也很常见，在一些有<code>构造函数/类</code>的模型，且每个模型对应一个模块的地方。一个 ES6 模块可以选择默认导出，作为最重要的导出值。默认导出特别易于导入。<p>下面的 ES6 模块默认导出是一个函数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ myFunc.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> () </span>&#123; ... &#125;;</span><br><br><span class="line"><span class="comment">//------ main1.js ------</span></span><br><span class="line"><span class="keyword">import</span> myFunc <span class="keyword">from</span> <span class="string">'myFunc'</span>;</span><br><span class="line">myFunc();</span><br></pre></table></figure><p>一个默认导出是一个类的 ES6 模块如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ MyClass.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123; ... &#125;;</span><br><br><span class="line"><span class="comment">//------ main2.js ------</span></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span>;</span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br></pre></table></figure><p>注意：默认导出的操作对象是一个表达式语句，通常没有名称；然而，它可以通过模块的名称（模块的文件名）来识别。<h4 id="3-3-在一个模块中同时使用命名导出和默认导出">3.3 在一个模块中同时使用命名导出和默认导出</h4><p>下面的模式在 JavaScript 中很常见：一个类库是单一的函数，但是通过改函数的属性提供了附加服务。jQuery 和 Underscores.js 都是这种方式的例子。下面是将 Underscore.js 写成 CommonJS 模块的草图：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ underscore.js ------</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> each = _.each = _.forEach =</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = _;</span><br></pre></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'underscore'</span>);</span><br><span class="line"><span class="keyword">var</span> each = _.each;</span><br><span class="line">...</span><br></pre></table></figure><p>从 ES6 来看，函数 _ 是默认导出，each 和 forEach 是命名导出。事实证明，你实际上可以同时使用命名导出和默认导出。看看下面的示例，前面的 CommonJS 模块用 ES6 模块的方式来写：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ underscore.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; each <span class="keyword">as</span> forEach &#125;;</span><br></pre></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; each &#125; <span class="keyword">from</span> <span class="string">'underscore'</span>;</span><br><span class="line">...</span><br></pre></table></figure><p>​ 注意，CommonJS 的版本和 ES6 的版本只是粗略的相似，后者具有更加扁平的结构，前者则是嵌套的。更偏向哪种风格是个人的喜好，但是扁平风格具有静态检查的优势（为什么这样做很好，下面解释）。CommonJS 风格似乎是部分受到了将对象作为命名空间的需求的驱动，这种需求通常可以通过 ES6 模块和命名导出的方式来实现。<h4 id="默认导出只是另一种形式的命名导出">默认导出只是另一种形式的命名导出</h4><p>​ 默认导出实际上是一种特殊的命名为 <code>default</code> 的命名导出。也就是说，下面的两种表达是等同的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br></pre></table></figure><p>​ 类似的，下面两个模块有相同的默认导出：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ module1.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">123</span>;</span><br><br><span class="line"><span class="comment">//------ module2.js ------</span></span><br><span class="line"><span class="keyword">const</span> D = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; D <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></table></figure><h4 id="我们为什么需要命名导出">我们为什么需要命名导出</h4><p>你可能想知道 — 如果我们可以简单地默认导出对象（像 CommonJS 一样），为什么需要命名导出？答案就是，你不能通过对象来强行使用静态结构，这会失去所有相关的有点（下一节中解释）。<h3 id="4-设计目标">4. 设计目标</h3><p>如果你想弄懂 ES6 模块，理解是什么样的目标影响了设计可能会帮到你，主要的目标就是：<ul><li>默认导出是有利的<li>静态模块结构<li>同时支持同步和异步加载<li>支持模块间循环引用</ul><p>下面的小节解释这些目标。<h4 id="4-1-默认导出是有利的">4.1 默认导出是有利的</h4><p>模块语法暗示了将默认导出当作模块可能看起来有些奇怪，但是如果你考虑到其中一个主要目标就是让默认导出尽可能方便的话就能说的通了。引用 David Herman:<blockquote><p>ECMAScript 6 favors the single/default export style, and gives the sweetest syntax to importing the default. Importing named exports can and even should be slightly less concise.</blockquote><h4 id="4-2-静态模块结构">4.2 静态模块结构</h4><p>​ 在现代 JavaScript 模块系统中，你必须运行代码才能知道导入和导出的是什么。这就是 ES6 打破了这些系统的主要原因：通过将模块系统建立到语言中，你可以在语法上强制执行静态模块结构。我们先看看这意味着什么，再看看它带来了什么好处：<p>​ 模块结构是静态的意味着你可以在编译时（静态的）决定导入和导出 — 你只需要看看源码，不必执行它。下面为什么 CommonJS 不可能做到静态检查的示例。在这个示例中，你必须运行代码才能知道它导入了什么：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">var</span> mylib;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random()) &#123;</span><br><span class="line">    mylib = <span class="built_in">require</span>(<span class="string">'foo'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mylib = <span class="built_in">require</span>(<span class="string">'bar'</span>);</span><br><span class="line">&#125;</span><br></pre></table></figure><p>第二个例子中，你必须运行代码才能知道导出了什么：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Math</span>.random()) &#123;</span><br><span class="line">    exports.baz = ...;</span><br><span class="line">&#125;</span><br></pre></table></figure><p>​ ES6 提供更少的灵活性，它会迫使你保持静态。你也会因此受益<sup>[<a href="http://calculist.org/blog/2012/06/29/static-module-resolution/" target="_blank" rel="noopener">2</a>]</sup>，下面介绍。<h5 id="好处-1-更快速的查找">好处 1: 更快速的查找</h5><p>​ 如果你用 CommonJS <code>require</code> 一个类库，你会得到一个 object ：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">var</span> lib = <span class="built_in">require</span>(<span class="string">'lib'</span>);</span><br><span class="line">lib.someFunc(); <span class="comment">// property lookup</span></span><br></pre></table></figure><p>​ 因此，通过 <code>lib.someFunc</code> 访问一个命名导出意味着你必须执行属性查询，这是很慢的，因为它是动态的。<p>​ 相反，如果你用 ES6 模块语法 <code>import</code> 一个类库，你可以静态地知道其内容并可以优化访问：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> lib <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br><span class="line">lib.someFunc(); <span class="comment">// statically resolved</span></span><br></pre></table></figure><h5 id="好处-2-变量检查">好处 2: 变量检查</h5><p>​ 有了静态模块结构，你就总能静态地知道模块内任意位置的哪些变量是可见的：<ul><li><p>Global variables: increasingly, the only completely global variables will come from the language proper. Everything else will come from modules (including functionality from the standard library and the browser). That is, you statically know all global variables.<li><p>Module imports: You statically know those, too.<li><p>Module-local variables: can be determined by statically examining the module.<br>This helps tremendously with checking whether a given identifier has been spelled properly. This kind of check is a popular feature of linters such as JSLint and JSHint; in ECMAScript 6, most of it can be performed by JavaScript engines.<p>另外，任何对命名导出的访问（例如 lib.foo）也可以静态检查。</ul><h5 id="好处3-准备好了宏">好处3: 准备好了宏</h5><p>​ 宏仍然在 JavaScript 未来的技术路线图中。如果 JavaScript 引擎支持了宏，你就可以通过类库添加新的语法。Sweet.js 就是一个实验性的 JavaScript 宏系统。下面是一个来自 Sweet.js 官网的示例：class 的宏<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre><td class="code"><pre><span class="line"><span class="comment">// Define the macro</span></span><br><span class="line">macro <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    rule &#123;</span><br><span class="line">        $className &#123;</span><br><span class="line">                <span class="keyword">constructor</span> $cparams $cbody</span><br><span class="line">                $($mname $mparams $mbody) ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; =&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">$className</span> <span class="title">$cparams</span> <span class="title">$cbody</span></span></span><br><span class="line"><span class="function">        <span class="title">$</span>(<span class="params">$className.prototype.$mname</span></span></span><br><span class="line"><span class="function"><span class="params">            = function $mname $mparams $mbody; </span>) ...</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function">// <span class="title">Use</span> <span class="title">the</span> <span class="title">macro</span></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    say(msg) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" says: "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bob = <span class="keyword">new</span> Person(<span class="string">"Bob"</span>);</span><br><span class="line">bob.say(<span class="string">"Macros are sweet!"</span>);</span><br></pre></table></figure><p>​ 对于宏，JavaScript 引擎在编译前会进行一个预处理步骤：如果解析器生成的 token 流中的 token 序列与宏的模式部分匹配，那么它将会被宏体生成的 token 替换。预处理步骤只在能够静态查找到宏定义的情况下有效。所以如果你想通过模块引入宏，那么模块必须是静态结构的。<h5 id="好处4-准备好了类型">好处4: 准备好了类型</h5><p>​ 静态类型检查强加了类似于宏的约束：它在定义能被静态地找到的情况下有用。同样，如果类型具有静态结构，只能从模块导入。<p>​ 类型很有吸引力，因为他们支持静态类型的 JavaScript 快速变体，其中可以编写性能关键代码。一个这样的变体就是 <a href="http://lljs.org/" target="_blank" rel="noopener">Low-Level JavaScript</a> (LLJS)。它现在被编译到了 <a href="http://2ality.com/2013/02/asm-js.html" target="_blank" rel="noopener">asm.js</a><h5 id="好处-5-支持其他语言">好处 5: 支持其他语言</h5><p>​ 如果你想要支持将使用宏和静态类型的语言编译到 JavaScript 中，JavaScript 的模块就应该有一个静态结构，这在前面两节讲过了。<h4 id="同时支持同步和异步加载">同时支持同步和异步加载</h4><p>​ ES6 模块必须在不论引擎同步（例如服务器端）还是异步（例如浏览器中）加载模块的情况下工作。它的语法非常适合同步加载，异步加载是通过静态结构实现的：因为你可以静态地决定所有的导入，所以可以在评估模块主题之前就加载他们（以一种类似 AMD 模块的方式）<h4 id="4-3-支持模块间的循环引用">4.3 支持模块间的循环引用</h4><p>​ 如果 A （可能间接/可传递地）导入了 B，同时 B 导入了 A，那么模块 A 和 B 就形成了<a href="https://en.wikipedia.org/wiki/Circular_dependency" target="_blank" rel="noopener">循环依赖</a>。如果可能，应该尽量避免循环依赖，它导致了 A 和 B 的紧耦合 — 它们只能同时引入和使用。<h5 id="为什么要支持循环依赖">为什么要支持循环依赖?</h5><p>​ 循环依赖本身并不是邪恶的。特别是对于对象，有时候你甚至需要这种依赖。例如，在一些树（例如 DOM 文档树）中，父亲指向孩子，同时孩子也指向父亲。在类库中，你通常会通过仔细的设计来避免循环依赖。在大型系统中，这种情况可能发生，尤其是在重构期间。然后，如果模块系统支持循环引用的话就非常有用了，因为重构时不会导致系统崩溃。<p>​ Node.js 文档中承认了循环依赖的重要性<sup>[<a href="https://nodejs.org/api/modules.html#modules_cycles" target="_blank" rel="noopener">3</a>]</sup> , Rob Sayre 提供了补充<a href="https://mail.mozilla.org/pipermail/es-discuss/2014-July/038250.html" target="_blank" rel="noopener">证明</a>：<blockquote><p>Data point: I once implemented a system like [ECMAScript 6 modules] for Firefox. I got asked for cyclic dependency support 3 weeks after shipping.<p>That system that Alex Fritze invented and I worked on is not perfect, and the syntax isn’t very pretty. But it’s still getting used 7 years later, so it must have gotten something right.</blockquote><p>​ 我们来看看 CommonJS 和 ES6 如何处理循环依赖。<h5 id="CommonJS-中的循环依赖">CommonJS 中的循环依赖</h5><p>​ 在 CommonJS 中，如果模块 B 依赖模块 A , 而 A 的主体正在评估中，那么它将返回 A 在当前状态中的导出对象（下面示例中的第一行）。这就允许 B 引用其导出内对象的属性（第二行）。这些属性在 B 的评估结束后填充，此时 B 的导出工作正常。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ a.js ------</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'b'</span>);</span><br><span class="line">exports.foo = <span class="function"><span class="keyword">function</span> () </span>&#123; ... &#125;;</span><br><br><span class="line"><span class="comment">//------ b.js ------</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>); <span class="comment">// (1)</span></span><br><span class="line"><span class="comment">// Can’t use a.foo in module body,</span></span><br><span class="line"><span class="comment">// but it will be filled in later</span></span><br><span class="line">exports.bar = <span class="function"><span class="keyword">function</span> () </span>&#123;</span><br><span class="line">    a.foo(); <span class="comment">// OK (2)</span></span><br><span class="line">&#125;;</span><br><br><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);</span><br></pre></table></figure><p>作为一般规则，需要记住，对于循环依赖，你无法访问模块正文中的导入。这是该现象固有的，并不能被 ES6 模块改变。<p>CommonJS 的方式有一些限制：<ul><li><p>Node.js 风格的单值导出不起作用。在 Node.js 中，你可以像这样导出单个值而不是对象：<br><code>module.exports = function () { ... }</code><p>如果你在模块 A 中这样做了，你就无法在模块 B 中使用导出的方法，因为 B 的变量 <code>a</code> 仍然指向 A 的原始导出对象。<li><p>你不能直接使用命名导出。也就是说，模块 B 不能像这样导入 <code>a.foo</code> ：<br><code>var foo = require(&#39;a&#39;).foo;</code><br>foo 将会是 undefined。换句话说，你没有其他选择，只能通过导出对象 <code>a</code> 来引用 foo。</ul><p>​ CommonJS 有一个独一无二的特点：你可以在导入之前导出。这种导出保证可以在引用的模块中被访问到。也就是说，如果 A 这样做了，那么它就可以在 B 中被访问到。然而在导入前导出的特性很少有用。<h5 id="ES6-中的循环引用">ES6 中的循环引用</h5><p>为了消除上述的两条限制，ES6 模块导出了绑定而不是值。也就是说与模块体内声明的变量的连接是保持鲜活的。在下面的代码中证明：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre><td class="code"><pre><span class="line"><span class="comment">//------ lib.js ------</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inc</span>() </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><br><span class="line"><span class="comment">//------ main.js ------</span></span><br><span class="line"><span class="keyword">import</span> &#123; inc, counter &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 0</span></span><br><span class="line">inc();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 1</span></span><br></pre></table></figure><p>​ 因此，对于循环依赖，不论你是直接访问命名导出还是通过模块访问都无关紧要：两种情况之间有间接联系，而且始终有效。<h3 id="5-再说一点导入和导出">5. 再说一点导入和导出</h3><h4 id="5-1-导入">5.1 导入</h4><p>​ ES6提供了下面这些方式的导入:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre><td class="code"><pre><span class="line"><span class="comment">// Default exports and named exports</span></span><br><span class="line"><span class="keyword">import</span> theDefault, &#123; named1, named2 &#125; <span class="keyword">from</span> <span class="string">'src/mylib'</span>;</span><br><span class="line"><span class="keyword">import</span> theDefault <span class="keyword">from</span> <span class="string">'src/mylib'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; named1, named2 &#125; <span class="keyword">from</span> <span class="string">'src/mylib'</span>;</span><br><br><span class="line"><span class="comment">// Renaming: import named1 as myNamed1</span></span><br><span class="line"><span class="keyword">import</span> &#123; named1 <span class="keyword">as</span> myNamed1, named2 &#125; <span class="keyword">from</span> <span class="string">'src/mylib'</span>;</span><br><br><span class="line"><span class="comment">// Importing the module as an object</span></span><br><span class="line"><span class="comment">// (with one property per named export)</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> mylib <span class="keyword">from</span> <span class="string">'src/mylib'</span>;</span><br><br><span class="line"><span class="comment">// Only load the module, don’t import anything</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'src/mylib'</span>;</span><br></pre></table></figure><h4 id="5-2-导出">5.2 导出</h4><p>​ 有两种方式可以导出当前模块中的东西。一种是你可以在声明前添加 <code>export</code> 关键字。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> myVar1 = ...;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> myVar2 = ...;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MY_CONST = ...;</span><br><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>() </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">myGeneratorFunc</span>() </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></table></figure><p>​ 默认导出的操作符是一个表达式（包括函数表达式和类表达式）。例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">123</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> x =&gt; x;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></table></figure><p>​ 另一方面，你可以将需要导出的任何东西列在模块末尾。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">const</span> MY_CONST = ...;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>() </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><br><span class="line"><span class="keyword">export</span> &#123; MY_CONST, myFunc &#125;;</span><br></pre></table></figure><p>​ 你也可以用不同的名字导出：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; MY_CONST <span class="keyword">as</span> THE_CONST, myFunc <span class="keyword">as</span> theFunc &#125;;</span><br></pre></table></figure><p>​ 注意，不能用保留字（例如，default 和 new ）作为变量名，但是你可以用他们作为导出名称（你也可以在 ES5 中用它们作为属性名称）。如果你想直接导入这样命名的导出，你必须要重命名成合适的名字。<h4 id="5-3-重导出">5.3 重导出</h4><p>​ 重导出意思是将另一个模块的导出添加到当前模块的导出中。你要么可以添加其他模块的全部导出：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'src/other_module'</span>;</span><br></pre></table></figure><p>​ 要么可以更有选择性（也可以重命名）：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'src/other_module'</span>;</span><br><br><span class="line"><span class="comment">// Export other_module’s foo as myFoo</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo, bar &#125; <span class="keyword">from</span> <span class="string">'src/other_module'</span>;</span><br></pre></table></figure><h3 id="6-eval-和-模块">6. eval() 和 模块</h3><p>​ eval() 不支持模块语法。它根据脚本的语法规则解析传入的参数，而脚本不支持模块语法（后面解释）。如果你想要评估模块代码，可以使用模块加载 API（接下来介绍）<h3 id="7-ES6-模块加载-API">7. ES6 模块加载 API</h3><p>除了使用模块的声明式语法外，还有一个编程 API，它允许你：<ul><li>用编程方式使用模块和脚本<li>配置模块加载</ul><p>​ 加载器处理解析模块标识符（位于<code>import…from</code> 后面的字符串 ID），加载模块等。他们的构造函数是 <code>Reflect.Loader</code> 。每个平台都在全局变量 System（系统加载器）中保留一个自定义实例，实现其特定的模块加载方式。<h4 id="7-1-引入模块和加载脚本">7.1 引入模块和加载脚本</h4><p>你可以通过基于 ES6 promise 的 API，编程化的导入一个模块：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><br><br></pre></table></figure><p>System.import() 允许你:<ul><li>使用<script>元素内的模块（这里不支持模块语法）</li>
<li>按条件加载模块</li>
</ul>
<p>System.import() 获取一个模块, 你可以用 Promise.all() 来导入多个模块:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(</span><br><span class="line">    [<span class="string">'module1'</span>, <span class="string">'module2'</span>, <span class="string">'module3'</span>]</span><br><span class="line">    .map(<span class="function"><span class="params">x</span> =&gt;</span> System.import(x)))</span><br><span class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Use module1, module2, module3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>更多加载器方法:</p>
<ul>
<li><code>System.module(source, options?)</code> 将source中的 JavaScript 代码评估为模块（这种方式通过 promise 异步传输）</li>
<li><code>System.set(name, module)</code> 这个方法用于注册一个模块（例如，一个你通过 System.module()创建的模块）。</li>
<li><code>System.define(name, source, options?)</code> 同时评估 source 中的模块代码和注册生成的模块。</li>
</ul>
<h4 id="7-4-配置模块加载"><a href="#7-4-配置模块加载" class="headerlink" title="7.4 配置模块加载"></a>7.4 配置模块加载</h4><p>模块加载器 API 有各种用于配置的 hooks（钩子），它仍在进行中。第一个用于浏览器的系统加载器目前已经实现并通过测试。目标是要弄清楚如何最好的实现模块加载可配置化。</p>
<p>The loader API will permit many customizations of the loading process. For example:</p>
<p>加载器 API 将会允许许多加载处理过程的自定义设置。例如：</p>
<ul>
<li>导入Lint模块(e.g. 通过 JSLint 还是 JSHint).</li>
<li>导入自动转椅模块(代码中可能包含 CoffeeScript 或者 TypeScript 代码).</li>
<li>使用遗留模块(AMD, Node.js).</li>
</ul>
<p>配置模块加载在 CommonJS 和 Node.js 中是受限制的</p></script></ul></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script type="text/javascript" src="https://code.jquery.com/jquery-1.7.1.min.js" integrity="sha256-iBcUE/x23aI6syuqF7EeT/+JFBxjPs5zeFJEXxumwb0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-sweetalert/1.0.1/sweetalert.min.js" integrity="sha256-JirYRqbf+qzfqVtEE4GETyHlAbiCpC005yBTa4rj6xg=" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-sweetalert/1.0.1/sweetalert.min.css" integrity="sha256-zuyRv+YsWwh1XR5tsrZ7VCfGqUmmPmqBjIvJgQWoSDo=" crossorigin="anonymous"><p><span>本文标题:</span>弄清 ECMAScript 6 模块<p><span>文章作者:</span>kinboy<p><span>发布时间:</span>2018年11月13日 - 15:56:58<p><span>最后更新:</span>2019年07月15日 - 18:05:10<p><span>原始链接:</span><a href="/2018/11/13/弄清-ECMAScript-6-模块/" title="弄清 ECMAScript 6 模块">http://kinboyw.github.io/2018/11/13/弄清-ECMAScript-6-模块/</a><span class="copy-path" title="点击复制文章链接"></span><p><span>许可协议:</span> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</div><script>var clipboard=new Clipboard(".fa-clipboard");clipboard.on("success",$(function(){$(".fa-clipboard").click(function(){swal({title:"",text:"复制成功",html:!1,timer:500,showConfirmButton:!1})})}))</script></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">------ Passage Ending ------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author:</strong> kinboy<li class="post-copyright-link"><strong>Post link:</strong> <a href="http://kinboyw.github.io/2018/11/13/弄清-ECMAScript-6-模块/" title="弄清 ECMAScript 6 模块">http://kinboyw.github.io/2018/11/13/弄清-ECMAScript-6-模块/</a><li class="post-copyright-license"><strong>Copyright Notice:</strong> All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/FE/" rel="tag"># FE</a> <a href="/tags/ES6/" rel="tag"># ES6</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/11/13/神奇的NaN/" rel="next" title="神奇的NaN">神奇的NaN</a></div><div class="post-nav-prev post-nav-item"><a href="/2018/11/14/JavaScript对象拷贝的误区/" rel="prev" title="JavaScript对象拷贝的误区">JavaScript对象拷贝的误区</a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents<li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="kinboy"><p class="site-author-name" itemprop="name">kinboy</div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">31</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">52</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate">RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/kinboyw" target="_blank" title="GitHub">GitHub</a></span><span class="links-of-author-item"><a href="mailto:kinboy9275@gmail.com" target="_blank" title="E-Mail"> E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JavaScript-的模块系统现状"><span class="nav-number">1.</span> <span class="nav-text">1. JavaScript 的模块系统现状</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ECMAScript-6-模块"><span class="nav-number">2.</span> <span class="nav-text">2. ECMAScript 6 模块</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ES6-模块语法概述"><span class="nav-number">3.</span> <span class="nav-text">3. ES6 模块语法概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-命名导出-（一对多模块）"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 命名导出 （一对多模块）</span></a><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-默认导出-（一对一模块）"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 默认导出 （一对一模块）</span></a><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-在一个模块中同时使用命名导出和默认导出"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 在一个模块中同时使用命名导出和默认导出</span></a><li class="nav-item nav-level-4"><a class="nav-link" href="#默认导出只是另一种形式的命名导出"><span class="nav-number">3.4.</span> <span class="nav-text">默认导出只是另一种形式的命名导出</span></a><li class="nav-item nav-level-4"><a class="nav-link" href="#我们为什么需要命名导出"><span class="nav-number">3.5.</span> <span class="nav-text">我们为什么需要命名导出</span></a></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#4-设计目标"><span class="nav-number">4.</span> <span class="nav-text">4. 设计目标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-默认导出是有利的"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 默认导出是有利的</span></a><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-静态模块结构"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 静态模块结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#好处-1-更快速的查找"><span class="nav-number">4.2.1.</span> <span class="nav-text">好处 1: 更快速的查找</span></a><li class="nav-item nav-level-5"><a class="nav-link" href="#好处-2-变量检查"><span class="nav-number">4.2.2.</span> <span class="nav-text">好处 2: 变量检查</span></a><li class="nav-item nav-level-5"><a class="nav-link" href="#好处3-准备好了宏"><span class="nav-number">4.2.3.</span> <span class="nav-text">好处3: 准备好了宏</span></a><li class="nav-item nav-level-5"><a class="nav-link" href="#好处4-准备好了类型"><span class="nav-number">4.2.4.</span> <span class="nav-text">好处4: 准备好了类型</span></a><li class="nav-item nav-level-5"><a class="nav-link" href="#好处-5-支持其他语言"><span class="nav-number">4.2.5.</span> <span class="nav-text">好处 5: 支持其他语言</span></a></ol><li class="nav-item nav-level-4"><a class="nav-link" href="#同时支持同步和异步加载"><span class="nav-number">4.3.</span> <span class="nav-text">同时支持同步和异步加载</span></a><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-支持模块间的循环引用"><span class="nav-number">4.4.</span> <span class="nav-text">4.3 支持模块间的循环引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要支持循环依赖"><span class="nav-number">4.4.1.</span> <span class="nav-text">为什么要支持循环依赖?</span></a><li class="nav-item nav-level-5"><a class="nav-link" href="#CommonJS-中的循环依赖"><span class="nav-number">4.4.2.</span> <span class="nav-text">CommonJS 中的循环依赖</span></a><li class="nav-item nav-level-5"><a class="nav-link" href="#ES6-中的循环引用"><span class="nav-number">4.4.3.</span> <span class="nav-text">ES6 中的循环引用</span></a></ol></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#5-再说一点导入和导出"><span class="nav-number">5.</span> <span class="nav-text">5. 再说一点导入和导出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-导入"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 导入</span></a><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-导出"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 导出</span></a><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-重导出"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 重导出</span></a></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#6-eval-和-模块"><span class="nav-number">6.</span> <span class="nav-text">6. eval() 和 模块</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#7-ES6-模块加载-API"><span class="nav-number">7.</span> <span class="nav-text">7. ES6 模块加载 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-引入模块和加载脚本"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 引入模块和加载脚本</span></a></ol></ol></div></div></section><div class="back-to-top"><span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love"></span> <span class="author" itemprop="copyrightHolder">kinboy</span><br><img src="/images/beian.png"> <span style="width:300px;margin:0 auto;padding:20px 0"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42011102002861" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src style="float:left"><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">鄂公网安备 42011102002861号</p></a></span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/three/three.min.js"></script><script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script id="dsq-count-scr" src="https://kinboy-wang.disqus.com/count.js" async></script><script type="text/javascript">var disqus_config=function(){this.page.url="http://kinboyw.github.io/2018/11/13/弄清-ECMAScript-6-模块/",this.page.identifier="2018/11/13/弄清-ECMAScript-6-模块/",this.page.title="弄清 ECMAScript 6 模块"},d=document,s=d.createElement("script");s.src="https://kinboy-wang.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script type="text/javascript">// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script>