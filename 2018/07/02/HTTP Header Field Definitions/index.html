<!DOCTYPE html><html class="theme-next gemini use-motion" lang="ZH | EN"><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="AKuwh4i11uWg0wOl_cM7AI_dHqOHOLKYfCxKc8Lfv6E"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="HTTP Header,Protocol,"><link rel="alternate" href="/atom.xml" title="Kinboy's note" type="application/atom+xml"><meta name="description" content="part of Hypertext Transfer Protocol – HTTP/1.1RFC 2616 Fielding, et al. 14 Header Field DefinitionsThis section defines the syntax and semantics of all standard HTTP/1.1 header fields. For entity-head"><meta name="keywords" content="HTTP Header,Protocol"><meta property="og:type" content="article"><meta property="og:title" content="Header Field Definitions"><meta property="og:url" content="http://kinboyw.github.io/2018/07/02/HTTP Header Field Definitions/index.html"><meta property="og:site_name" content="Kinboy&#39;s note"><meta property="og:description" content="part of Hypertext Transfer Protocol – HTTP/1.1RFC 2616 Fielding, et al. 14 Header Field DefinitionsThis section defines the syntax and semantics of all standard HTTP/1.1 header fields. For entity-head"><meta property="og:locale" content="ZH | EN"><meta property="og:updated_time" content="2019-07-15T10:05:10.342Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Header Field Definitions"><meta name="twitter:description" content="part of Hypertext Transfer Protocol – HTTP/1.1RFC 2616 Fielding, et al. 14 Header Field DefinitionsThis section defines the syntax and semantics of all standard HTTP/1.1 header fields. For entity-head"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"I didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://kinboyw.github.io/2018/07/02/HTTP Header Field Definitions/"><title>Header Field Definitions | Kinboy's note</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c9c2b9e915e6bb8ec323a2f98c0c98d8";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><body itemscope itemtype="http://schema.org/WebPage" lang="ZH | EN"><div class="container sidebar-position-left page-post-detail"><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"></span><span class="site-title">Kinboy's note</span><span class="logo-line-after"></span></a></div><h1 class="site-subtitle" itemprop="description">前端漫记</h1></div><div class="site-nav-toggle"><button></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><br>Home</a><li class="menu-item menu-item-about"><a href="/rscard/" rel="section"><br>About</a><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><br>Tags</a><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><br>Categories</a><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><br>Archives</a><li class="menu-item menu-item-top"><a href="/top/" rel="section"><br>Top</a><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><br>Search</a></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"></span><span class="popup-btn-close"></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://kinboyw.github.io/2018/07/02/HTTP Header Field Definitions/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="kinboy"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Kinboy's note"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Header Field Definitions</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"></span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-02T17:25:21+08:00">2018-07-02</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/翻译/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/FE/" itemprop="url" rel="index"><span itemprop="name">FE</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/FE/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"></span><a href="/2018/07/02/HTTP Header Field Definitions/#comments" itemprop="discussionUrl"></a></span><div class="post-wordcount"><span class="post-meta-item-icon"></span><span class="post-meta-item-text">Words count in article&#58;</span> <span title="Words count in article">17.9k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"></span> <span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">111</span></div></div></header><div class="post-body" itemprop="articleBody"><p>part of <a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank" rel="noopener">Hypertext Transfer Protocol – HTTP/1.1</a><br>RFC 2616 Fielding, et al.<h2 id="14-Header-Field-Definitions">14 Header Field Definitions</h2><p>This section defines the syntax and semantics of all standard HTTP/1.1 header fields. For entity-header fields, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity.<blockquote><p>这部分定义了所有标准 HTTP/1.1 头部字段的语法和语义。对 实体头部字段，发送者和接收者指客户端或者服务器，取决于谁发送以及谁接收实体</blockquote><h3 id="14-1-Accept">14.1 Accept</h3><p>The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.<blockquote><p>Accept 请求头可以被用于指定可接收的请求响应中的媒体类型。Accept 头部可以用于指示请求只限于特定一小组所需的类型，例如在在请求一个内嵌图片的时候可以指定图片的格式等。</blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre><td class="code"><pre><span class="line">Accept         = "Accept" ":"</span><br><span class="line">                 #( media-range [ accept-params ] )</span><br><span class="line">media-range    = ( "*/*"</span><br><span class="line">                 | ( type "/" "*" )</span><br><span class="line">                 | ( type "/" subtype )</span><br><span class="line">                 ) *( ";" parameter )</span><br><span class="line">accept-params  = ";" "q" "=" qvalue *( accept-extension )</span><br><span class="line">accept-extension = ";" token [ "=" ( token | quoted-string ) ]</span><br></pre></table></figure><p>The asterisk “<em>“ character is used to group media types into ranges, with “</em>/<em>“ indicating all media types and “type/</em>“ indicating all subtypes of that type. The media-range MAY include media type parameters that are applicable to that range.<p>Each media-range MAY be followed by one or more accept-params, beginning with the “q” parameter for indicating a relative quality factor. The first “q” parameter (if any) separates the media-range parameter(s) from the accept-params. Quality factors allow the user or user agent to indicate the relative degree of preference for that media-range, using the qvalue scale from 0 to 1 (section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9" target="_blank" rel="noopener">3.9</a>). The default value is q=1.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre><td class="code"><pre><span class="line">Note: Use of the &quot;q&quot; parameter name to separate media type</span><br><span class="line">parameters from Accept extension parameters is due to historical</span><br><span class="line">practice. Although this prevents any media type parameter named</span><br><span class="line">&quot;q&quot; from being used with a media range, such an event is believed</span><br><span class="line">to be unlikely given the lack of any &quot;q&quot; parameters in the IANA</span><br><span class="line">media type registry and the rare usage of any media type</span><br><span class="line">parameters in Accept. Future media types are discouraged from</span><br><span class="line">registering any parameter named &quot;q&quot;.</span><br></pre></table></figure><p>The example<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Accept: audio/*; q=0.2, audio/basic</span><br></pre></table></figure><p>SHOULD be interpreted as “I prefer audio/basic, but send me any audio type if it is the best available after an 80% mark-down in quality.”<p>If no Accept header field is present, then it is assumed that the client accepts all media types. If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.<p>A more elaborate example is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">Accept: text/plain; q=0.5, text/html,</span><br><span class="line">        text/x-dvi; q=0.8, text/x-c</span><br></pre></table></figure><p>Verbally, this would be interpreted as “text/html and text/x-c are the preferred media types, but if they do not exist, then send the text/x-dvi entity, and if that does not exist, send the text/plain entity.”<p>Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies to a given type, the most specific reference has precedence. For example,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Accept: text/*, text/html, text/html;level=1, */*</span><br></pre></table></figure><p>have the following precedence:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre><td class="code"><pre><span class="line">1) text/html;level=1</span><br><span class="line">2) text/html</span><br><span class="line">3) text/*</span><br><span class="line">4) */*</span><br></pre></table></figure><p>The media type quality factor associated with a given type is determined by finding the media range with the highest precedence which matches that type. For example,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,</span><br><span class="line">        text/html;level=2;q=0.4, */*;q=0.5</span><br></pre></table></figure><p>would cause the following values to be associated:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre><td class="code"><pre><span class="line"> text/html;level=1         = 1</span><br><span class="line"> text/html                 = 0.7</span><br><span class="line"> text/plain                = 0.3</span><br><span class="line"> image/jpeg                = 0.5</span><br><span class="line"> text/html;level=2         = 0.4</span><br><span class="line"> text/html;level=3         = 0.7</span><br><span class="line">Note: A user agent might be provided with a default set of quality</span><br><span class="line">values for certain media ranges. However, unless the user agent is</span><br><span class="line">a closed system which cannot interact with other rendering agents,</span><br><span class="line">this default set ought to be configurable by the user.</span><br></pre></table></figure><h3 id="14-2-Accept-Charset">14.2 Accept-Charset</h3><p>The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. This field allows clients capable of understanding more comprehensive or special- purpose character sets to signal that capability to a server which is capable of representing documents in those character sets.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;</span><br><span class="line">        1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )</span><br></pre></table></figure><p>Character set values are described in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.4" target="_blank" rel="noopener">3.4</a>. Each charset MAY be given an associated quality value which represents the user’s preference for that charset. The default value is q=1. An example is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5, unicode-1-1;q=0.8</span><br></pre></table></figure><p>The special value “<em>“, if present in the Accept-Charset field, matches every character set (including ISO-8859-1) which is not mentioned elsewhere in the Accept-Charset field. If no “</em>“ is present in an Accept-Charset field, then all character sets not explicitly mentioned get a quality value of 0, except for ISO-8859-1, which gets a quality value of 1 if not explicitly mentioned.<p>If no Accept-Charset header is present, the default is that any character set is acceptable. If an Accept-Charset header is present, and if the server cannot send a response which is acceptable according to the Accept-Charset header, then the server SHOULD send an error response with the 406 (not acceptable) status code, though the sending of an unacceptable response is also allowed.<h3 id="14-3-Accept-Encoding">14.3 Accept-Encoding</h3><p>The Accept-Encoding request-header field is similar to Accept, but restricts the content-codings (section 3.5) that are acceptable in the response.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line">Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot;</span><br><span class="line">                   1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )</span><br><span class="line">codings          = ( content-coding | &quot;*&quot; )</span><br></pre></table></figure><p>Examples of its use are:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre><td class="code"><pre><span class="line">Accept-Encoding: compress, gzip</span><br><span class="line">Accept-Encoding:</span><br><span class="line">Accept-Encoding: *</span><br><span class="line">Accept-Encoding: compress;q=0.5, gzip;q=1.0</span><br><span class="line">Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0</span><br></pre></table></figure><p>A server tests whether a content-coding is acceptable, according to an Accept-Encoding field, using these rules:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre><td class="code"><pre><span class="line">1. If the content-coding is one of the content-codings listed in</span><br><span class="line">   the Accept-Encoding field, then it is acceptable, unless it is</span><br><span class="line">   accompanied by a qvalue of 0. (As defined in section 3.9, a</span><br><span class="line">   qvalue of 0 means &quot;not acceptable.&quot;)</span><br><span class="line">2. The special &quot;*&quot; symbol in an Accept-Encoding field matches any</span><br><span class="line">   available content-coding not explicitly listed in the header</span><br><span class="line">   field.</span><br><span class="line">3. If multiple content-codings are acceptable, then the acceptable</span><br><span class="line">   content-coding with the highest non-zero qvalue is preferred.</span><br><span class="line">4. The &quot;identity&quot; content-coding is always acceptable, unless</span><br><span class="line">   specifically refused because the Accept-Encoding field includes</span><br><span class="line">   &quot;identity;q=0&quot;, or because the field includes &quot;*;q=0&quot; and does</span><br><span class="line">   not explicitly include the &quot;identity&quot; content-coding. If the</span><br><span class="line">   Accept-Encoding field-value is empty, then only the &quot;identity&quot;</span><br><span class="line">   encoding is acceptable.</span><br></pre></table></figure><p>If an Accept-Encoding field is present in a request, and if the server cannot send a response which is acceptable according to the Accept-Encoding header, then the server SHOULD send an error response with the 406 (Not Acceptable) status code.<p>If no Accept-Encoding field is present in a request, the server MAY assume that the client will accept any content coding. In this case, if “identity” is one of the available content-codings, then the server SHOULD use the “identity” content-coding, unless it has additional information that a different content-coding is meaningful to the client.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre><td class="code"><pre><span class="line">Note: If the request does not include an Accept-Encoding field,</span><br><span class="line">and if the &quot;identity&quot; content-coding is unavailable, then</span><br><span class="line">content-codings commonly understood by HTTP/1.0 clients (i.e.,</span><br><span class="line">&quot;gzip&quot; and &quot;compress&quot;) are preferred; some older clients</span><br><span class="line">improperly display messages sent with other content-codings.  The</span><br><span class="line">server might also make this decision based on information about</span><br><span class="line">the particular user-agent or client.</span><br><span class="line">Note: Most HTTP/1.0 applications do not recognize or obey qvalues</span><br><span class="line">associated with content-codings. This means that qvalues will not</span><br><span class="line">work and are not permitted with x-gzip or x-compress.</span><br></pre></table></figure><h3 id="14-4-Accept-Language">14.4 Accept-Language</h3><p>The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. Language tags are defined in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.10" target="_blank" rel="noopener">3.10</a>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line">Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;</span><br><span class="line">                  1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )</span><br><span class="line">language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )</span><br></pre></table></figure><p>Each language-range MAY be given an associated quality value which represents an estimate of the user’s preference for the languages specified by that range. The quality value defaults to “q=1”. For example,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Accept-Language: da, en-gb;q=0.8, en;q=0.7</span><br></pre></table></figure><p>would mean: “I prefer Danish, but will accept British English and other types of English.” A language-range matches a language-tag if it exactly equals the tag, or if it exactly equals a prefix of the tag such that the first tag character following the prefix is “-“. The special range “*”, if present in the Accept-Language field, matches every tag not matched by any other range present in the Accept-Language field.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre><td class="code"><pre><span class="line">Note: This use of a prefix matching rule does not imply that</span><br><span class="line">language tags are assigned to languages in such a way that it is</span><br><span class="line">always true that if a user understands a language with a certain</span><br><span class="line">tag, then this user will also understand all languages with tags</span><br><span class="line">for which this tag is a prefix. The prefix rule simply allows the</span><br><span class="line">use of prefix tags if this is the case.</span><br></pre></table></figure><p>The language quality factor assigned to a language-tag by the Accept-Language field is the quality value of the longest language- range in the field that matches the language-tag. If no language- range in the field matches the tag, the language quality factor assigned is 0. If no Accept-Language header is present in the request, the server<p>SHOULD assume that all languages are equally acceptable. If an Accept-Language header is present, then all languages which are assigned a quality factor greater than 0 are acceptable.<p>It might be contrary to the privacy expectations of the user to send an Accept-Language header with the complete linguistic preferences of the user in every request. For a discussion of this issue, see section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.4" target="_blank" rel="noopener">15.1.4</a>.<p>As intelligibility is highly dependent on the individual user, it is recommended that client applications make the choice of linguistic preference available to the user. If the choice is not made available, then the Accept-Language header field MUST NOT be given in the request.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre><td class="code"><pre><span class="line">Note: When making the choice of linguistic preference available to</span><br><span class="line">the user, we remind implementors of  the fact that users are not</span><br><span class="line">familiar with the details of language matching as described above,</span><br><span class="line">and should provide appropriate guidance. As an example, users</span><br><span class="line">might assume that on selecting &quot;en-gb&quot;, they will be served any</span><br><span class="line">kind of English document if British English is not available. A</span><br><span class="line">user agent might suggest in such a case to add &quot;en&quot; to get the</span><br><span class="line">best matching behavior.</span><br></pre></table></figure><h3 id="14-5-Accept-Ranges">14.5 Accept-Ranges</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre><td class="code"><pre><span class="line">The Accept-Ranges response-header field allows the server to</span><br><span class="line">indicate its acceptance of range requests for a resource:</span><br><span class="line">    Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges</span><br><span class="line">    acceptable-ranges = 1#range-unit | &quot;none&quot;</span><br><span class="line">Origin servers that accept byte-range requests MAY send</span><br><span class="line">    Accept-Ranges: bytes</span><br><span class="line">but are not required to do so. Clients MAY generate byte-range</span><br><span class="line">requests without having received this header for the resource</span><br><span class="line">involved. Range units are defined in section 3.12.</span><br><span class="line">Servers that do not accept any kind of range request for a</span><br><span class="line">resource MAY send</span><br><span class="line">    Accept-Ranges: none</span><br><span class="line">to advise the client not to attempt a range request.</span><br></pre></table></figure><h3 id="14-6-Age">14.6 Age</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre><td class="code"><pre><span class="line">The Age response-header field conveys the sender&apos;s estimate of the</span><br><span class="line">amount of time since the response (or its revalidation) was</span><br><span class="line">generated at the origin server. A cached response is &quot;fresh&quot; if</span><br><span class="line">its age does not exceed its freshness lifetime. Age values are</span><br><span class="line">calculated as specified in section 13.2.3.</span><br><span class="line">     Age = &quot;Age&quot; &quot;:&quot; age-value</span><br><span class="line">     age-value = delta-seconds</span><br><span class="line">Age values are non-negative decimal integers, representing time in</span><br><span class="line">seconds.</span><br><span class="line">If a cache receives a value larger than the largest positive</span><br><span class="line">integer it can represent, or if any of its age calculations</span><br><span class="line">overflows, it MUST transmit an Age header with a value of</span><br><span class="line">2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST</span><br><span class="line">include an Age header field in every response generated from its</span><br><span class="line">own cache. Caches SHOULD use an arithmetic type of at least 31</span><br><span class="line">bits of range.</span><br></pre></table></figure><h3 id="14-7-Allow">14.7 Allow</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre><td class="code"><pre><span class="line">The Allow entity-header field lists the set of methods supported</span><br><span class="line">by the resource identified by the Request-URI. The purpose of this</span><br><span class="line">field is strictly to inform the recipient of valid methods</span><br><span class="line">associated with the resource. An Allow header field MUST be</span><br><span class="line">present in a 405 (Method Not Allowed) response.</span><br><span class="line">    Allow   = &quot;Allow&quot; &quot;:&quot; #Method</span><br><span class="line">Example of use:</span><br><span class="line">    Allow: GET, HEAD, PUT</span><br><span class="line">This field cannot prevent a client from trying other methods.</span><br><span class="line">However, the indications given by the Allow header field value</span><br><span class="line">SHOULD be followed. The actual set of allowed methods is defined</span><br><span class="line">by the origin server at the time of each request.</span><br><span class="line">The Allow header field MAY be provided with a PUT request to</span><br><span class="line">recommend the methods to be supported by the new or modified</span><br><span class="line">resource. The server is not required to support these methods and</span><br><span class="line">SHOULD include an Allow header in the response giving the actual</span><br><span class="line">supported methods.</span><br><span class="line">A proxy MUST NOT modify the Allow header field even if it does not</span><br><span class="line">understand all the methods specified, since the user agent might</span><br><span class="line">have other means of communicating with the origin server.</span><br></pre></table></figure><h3 id="14-8-Authorization">14.8 Authorization</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre><td class="code"><pre><span class="line">A user agent that wishes to authenticate itself with a server--</span><br><span class="line">usually, but not necessarily, after receiving a 401 response--does</span><br><span class="line">so by including an Authorization request-header field with the</span><br><span class="line">request.  The Authorization field value consists of credentials</span><br><span class="line">containing the authentication information of the user agent for</span><br><span class="line">the realm of the resource being requested.</span><br><span class="line">    Authorization  = &quot;Authorization&quot; &quot;:&quot; credentials</span><br><span class="line">HTTP access authentication is described in &quot;HTTP Authentication:</span><br><span class="line">Basic and Digest Access Authentication&quot; [43]. If a request is</span><br><span class="line">authenticated and a realm specified, the same credentials SHOULD</span><br><span class="line">be valid for all other requests within this realm (assuming that</span><br><span class="line">the authentication scheme itself does not require otherwise, such</span><br><span class="line">as credentials that vary according to a challenge value or using</span><br><span class="line">synchronized clocks).</span><br><span class="line">When a shared cache (see section 13.7) receives a request</span><br><span class="line">containing an Authorization field, it MUST NOT return the</span><br><span class="line">corresponding response as a reply to any other request, unless one</span><br><span class="line">of the following specific exceptions holds:</span><br><span class="line">1. If the response includes the &quot;s-maxage&quot; cache-control</span><br><span class="line">   directive, the cache MAY use that response in replying to a</span><br><span class="line">   subsequent request. But (if the specified maximum age has</span><br><span class="line">   passed) a proxy cache MUST first revalidate it with the origin</span><br><span class="line">   server, using the request-headers from the new request to allow</span><br><span class="line">   the origin server to authenticate the new request. (This is the</span><br><span class="line">   defined behavior for s-maxage.) If the response includes &quot;s-</span><br><span class="line">   maxage=0&quot;, the proxy MUST always revalidate it before re-using</span><br><span class="line">   it.</span><br><span class="line">2. If the response includes the &quot;must-revalidate&quot; cache-control</span><br><span class="line">   directive, the cache MAY use that response in replying to a</span><br><span class="line">   subsequent request. But if the response is stale, all caches</span><br><span class="line">   MUST first revalidate it with the origin server, using the</span><br><span class="line">   request-headers from the new request to allow the origin server</span><br><span class="line">   to authenticate the new request.</span><br><span class="line">3. If the response includes the &quot;public&quot; cache-control directive,</span><br><span class="line">   it MAY be returned in reply to any subsequent request.</span><br></pre></table></figure><h3 id="14-9-Cache-Control">14.9 Cache-Control</h3><p>The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. The directives specify behavior intended to prevent caches from adversely interfering with the request or response. These directives typically override the default caching algorithms. Cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is to be given in the response.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">Note that HTTP/1.0 caches might not implement Cache-Control and</span><br><span class="line">might only implement Pragma: no-cache (see section 14.32).</span><br></pre></table></figure><p>Cache directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a cache- directive for a specific cache.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre><td class="code"><pre><span class="line">Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive</span><br><span class="line">cache-directive = cache-request-directive</span><br><span class="line">     | cache-response-directive</span><br><span class="line">cache-request-directive =</span><br><span class="line">       &quot;no-cache&quot;                          ; Section 14.9.1</span><br><span class="line">     | &quot;no-store&quot;                          ; Section 14.9.2</span><br><span class="line">     | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; Section 14.9.3, 14.9.4</span><br><span class="line">     | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; Section 14.9.3</span><br><span class="line">     | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; Section 14.9.3</span><br><span class="line">     | &quot;no-transform&quot;                      ; Section 14.9.5</span><br><span class="line">     | &quot;only-if-cached&quot;                    ; Section 14.9.4</span><br><span class="line">     | cache-extension                     ; Section 14.9.6</span><br><span class="line"> cache-response-directive =</span><br><span class="line">       &quot;public&quot;                               ; Section 14.9.1</span><br><span class="line">     | &quot;private&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ] ; Section 14.9.1</span><br><span class="line">     | &quot;no-cache&quot; [ &quot;=&quot; &lt;&quot;&gt; 1#field-name &lt;&quot;&gt; ]; Section 14.9.1</span><br><span class="line">     | &quot;no-store&quot;                             ; Section 14.9.2</span><br><span class="line">     | &quot;no-transform&quot;                         ; Section 14.9.5</span><br><span class="line">     | &quot;must-revalidate&quot;                      ; Section 14.9.4</span><br><span class="line">     | &quot;proxy-revalidate&quot;                     ; Section 14.9.4</span><br><span class="line">     | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; Section 14.9.3</span><br><span class="line">     | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; Section 14.9.3</span><br><span class="line">     | cache-extension                        ; Section 14.9.6</span><br><span class="line">cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ]</span><br></pre></table></figure><p>When a directive appears without any 1#field-name parameter, the directive applies to the entire request or response. When such a directive appears with a 1#field-name parameter, it applies only to the named field or fields, and not to the rest of the request or response. This mechanism supports extensibility; implementations of future versions of the HTTP protocol might apply these directives to header fields not defined in HTTP/1.1.<p>The cache-control directives can be broken down into these general categories:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre><td class="code"><pre><span class="line">- Restrictions on what are cacheable; these may only be imposed by</span><br><span class="line">  the origin server.</span><br><span class="line">- Restrictions on what may be stored by a cache; these may be</span><br><span class="line">  imposed by either the origin server or the user agent.</span><br><span class="line">- Modifications of the basic expiration mechanism; these may be</span><br><span class="line">  imposed by either the origin server or the user agent.</span><br><span class="line">- Controls over cache revalidation and reload; these may only be</span><br><span class="line">  imposed by a user agent.</span><br><span class="line">- Control over transformation of entities.</span><br><span class="line">- Extensions to the caching system.</span><br></pre></table></figure><h3 id="14-9-1-What-is-Cacheable">14.9.1 What is Cacheable</h3><p>By default, a response is cacheable if the requirements of the request method, request header fields, and the response status indicate that it is cacheable. Section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4" target="_blank" rel="noopener">13.4</a> summarizes these defaults for cacheability. The following Cache-Control response directives allow an origin server to override the default cacheability of a response:<ul><li><p>public<p>Indicates that the response MAY be cached by any cache, even if it would normally be non-cacheable or cacheable only within a non- shared cache. (See also Authorization, section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.8" target="_blank" rel="noopener">14.8</a>, for additional details.)<li><p>private<p>Indicates that all or part of the response message is intended for a single user and MUST NOT be cached by a shared cache. This allows an origin server to state that the specified parts of the<li><p>response are intended for only one user and are not a valid response for requests by other users. A private (non-shared) cache MAY cache the response.<p><strong>Note:</strong> This usage of the word private only controls where the response may be cached, and cannot ensure the privacy of the message content.<li><p>no-cache<p>If the no-cache directive does not specify a field-name, then a cache MUST NOT use the response to satisfy a subsequent request without successful revalidation with the origin server. This allows an origin server to prevent caching even by caches that have been configured to return stale responses to client requests.<li><p>If the no-cache directive does specify one or more field-names, then a cache MAY use the response to satisfy a subsequent request, subject to any other restrictions on caching. However, the specified field-name(s) MUST NOT be sent in the response to a subsequent request without successful revalidation with the origin server. This allows an origin server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response.<p><strong>Note:</strong> Most HTTP/1.0 caches will not recognize or obey this directive.</ul><h3 id="14-9-2-What-May-be-Stored-by-Caches">14.9.2 What May be Stored by Caches</h3><ul><li><p>no-store<p>The purpose of the no-store directive is to prevent the inadvertent release or retention of sensitive information (for example, on backup tapes). The no-store directive applies to the entire message, and MAY be sent either in a response or in a request. If sent in a request, a cache MUST NOT store any part of either this request or any response to it. If sent in a response, a cache MUST NOT store any part of either this response or the request that elicited it. This directive applies to both non- shared and shared caches. “MUST NOT store” in this context means that the cache MUST NOT intentionally store the information in non-volatile storage, and MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.<li><p>Even when this directive is associated with a response, users might explicitly store such a response outside of the caching system (e.g., with a “Save As” dialog). History buffers MAY store such responses as part of their normal operation.<li><p>The purpose of this directive is to meet the stated requirements of certain users and service authors who are concerned about accidental releases of information via unanticipated accesses to cache data structures. While the use of this directive might improve privacy in some cases, we caution that it is NOT in any way a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.</ul><h3 id="14-9-3-Modifications-of-the-Basic-Expiration-Mechanism">14.9.3 Modifications of the Basic Expiration Mechanism</h3><p>The expiration time of an entity MAY be specified by the origin server using the Expires header (see section 14.21). Alternatively, it MAY be specified using the max-age directive in a response. When the max-age cache-control directive is present in a cached response, the response is stale if its current age is greater than the age value given (in seconds) at the time of a new request for that resource. The max-age directive on a response implies that the response is cacheable (i.e., “public”) unless some other, more restrictive cache directive is also present.<p>If a response includes both an Expires header and a max-age directive, the max-age directive overrides the Expires header, even if the Expires header is more restrictive. This rule allows an origin server to provide, for a given response, a longer expiration time to an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be useful if certain HTTP/1.0 caches improperly calculate ages or expiration times, perhaps due to desynchronized clocks.<p>Many HTTP/1.0 cache implementations will treat an Expires value that is less than or equal to the response Date value as being equivalent to the Cache-Control response directive “no-cache”. If an HTTP/1.1 cache receives such a response, and the response does not include a Cache-Control header field, it SHOULD consider the response to be non-cacheable in order to retain compatibility with HTTP/1.0 servers.<p><strong>Note:</strong> An origin server might wish to use a relatively new HTTP cache control feature, such as the “private” directive, on a network including older caches that do not understand that feature. The origin server will need to combine the new feature with an Expires field whose value is less than or equal to the Date value. This will prevent older caches from improperly caching the response.<ul><li><p>s-maxage<p>If a response includes an s-maxage directive, then for a shared cache (but not for a private cache), the maximum age specified by this directive overrides the maximum age specified by either the max-age directive or the Expires header. The s-maxage directive also implies the semantics of the proxy-revalidate directive (see section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4" target="_blank" rel="noopener">14.9.4</a>), i.e., that the shared cache must not use the entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server. The s- maxage directive is always ignored by a private cache.</ul><p>Note that most older caches, not compliant with this specification, do not implement any cache-control directives. An origin server wishing to use a cache-control directive that restricts, but does not prevent, caching by an HTTP/1.1-compliant cache MAY exploit the requirement that the max-age directive overrides the Expires header, and the fact that pre-HTTP/1.1-compliant caches do not observe the max-age directive.<p>Other directives allow a user agent to modify the basic expiration mechanism. These directives MAY be specified on a request:<ul><li><p>max-age<p>Indicates that the client is willing to accept a response whose age is no greater than the specified time in seconds. Unless max- stale directive is also included, the client is not willing to accept a stale response.<li><p>min-fresh<p>Indicates that the client is willing to accept a response whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.<li><p>max-stale<p>Indicates that the client is willing to accept a response that has exceeded its expiration time. If max-stale is assigned a value, then the client is willing to accept a response that has exceeded its expiration time by no more than the specified number of seconds. If no value is assigned to max-stale, then the client is willing to accept a stale response of any age.</ul><p>If a cache returns a stale response, either because of a max-stale directive on a request, or because the cache is configured to override the expiration time of a response, the cache MUST attach a Warning header to the stale response, using Warning 110 (Response is stale).<p>A cache MAY be configured to return stale responses without validation, but only if this does not conflict with any “MUST”-level requirements concerning cache validation (e.g., a “must-revalidate” cache-control directive).<p>If both the new request and the cached entry include “max-age” directives, then the lesser of the two values is used for determining the freshness of the cached entry for that request.<h3 id="14-9-4-Cache-Revalidation-and-Reload-Controls">14.9.4 Cache Revalidation and Reload Controls</h3><p>Sometimes a user agent might want or need to insist that a cache revalidate its cache entry with the origin server (and not just with the next cache along the path to the origin server), or to reload its cache entry from the origin server. End-to-end revalidation might be necessary if either the cache or the origin server has overestimated the expiration time of the cached response. End-to-end reload may be necessary if the cache entry has become corrupted for some reason.<p>End-to-end revalidation may be requested either when the client does not have its own local cached copy, in which case we call it “unspecified end-to-end revalidation”, or when the client does have a local cached copy, in which case we call it “specific end-to-end revalidation.”<p>The client can specify these three kinds of action using Cache- Control request directives:<ul><li><p>End-to-end reload<p>The request includes a “no-cache” cache-control directive or, for compatibility with HTTP/1.0 clients, “Pragma: no-cache”. Field names MUST NOT be included with the no-cache directive in a request. The server MUST NOT use a cached copy when responding to such a request.<li><p>Specific end-to-end revalidation<p>The request includes a “max-age=0” cache-control directive, which forces each cache along the path to the origin server to revalidate its own entry, if any, with the next cache or server. The initial request includes a cache-validating conditional with the client’s current validator.<li><p>Unspecified end-to-end revalidation<p>The request includes “max-age=0” cache-control directive, which forces each cache along the path to the origin server to revalidate its own entry, if any, with the next cache or server. The initial request does not include a cache-validating<li><p>conditional; the first cache along the path (if any) that holds a cache entry for this resource includes a cache-validating conditional with its current validator.<li><p>max-age<p>When an intermediate cache is forced, by means of a max-age=0 directive, to revalidate its own cache entry, and the client has supplied its own validator in the request, the supplied validator might differ from the validator currently stored with the cache entry. In this case, the cache MAY use either validator in making its own request without affecting semantic transparency.<li><p>However, the choice of validator might affect performance. The best approach is for the intermediate cache to use its own validator when making its request. If the server replies with 304 (Not Modified), then the cache can return its now validated copy to the client with a 200 (OK) response. If the server replies with a new entity and cache validator, however, the intermediate cache can compare the returned validator with the one provided in the client’s request, using the strong comparison function. If the client’s validator is equal to the origin server’s, then the intermediate cache simply returns 304 (Not Modified). Otherwise, it returns the new entity with a 200 (OK) response.<li><p>If a request includes the no-cache directive, it SHOULD NOT include min-fresh, max-stale, or max-age.<li><p>only-if-cached<p>In some cases, such as times of extremely poor network connectivity, a client may want a cache to return only those responses that it currently has stored, and not to reload or revalidate with the origin server. To do this, the client may include the only-if-cached directive in a request. If it receives this directive, a cache SHOULD either respond using a cached entry that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status. However, if a group of caches is being operated as a unified system with good internal connectivity, such a request MAY be forwarded within that group of caches.<li><p>must-revalidate<p>Because a cache MAY be configured to ignore a server’s specified expiration time, and because a client request MAY include a max- stale directive (which has a similar effect), the protocol also includes a mechanism for the origin server to require revalidation of a cache entry on any subsequent use. When the must-revalidate directive is present in a response received by a cache, that cache MUST NOT use the entry after it becomes stale to respond to a<li><p>subsequent request without first revalidating it with the origin server. (I.e., the cache MUST do an end-to-end revalidation every time, if, based solely on the origin server’s Expires or max-age value, the cached response is stale.)<li><p>The must-revalidate directive is necessary to support reliable operation for certain protocol features. In all circumstances an HTTP/1.1 cache MUST obey the must-revalidate directive; in particular, if the cache cannot reach the origin server for any reason, it MUST generate a 504 (Gateway Timeout) response.<li><p>Servers SHOULD send the must-revalidate directive if and only if failure to revalidate a request on the entity could result in incorrect operation, such as a silently unexecuted financial transaction. Recipients MUST NOT take any automated action that violates this directive, and MUST NOT automatically provide an unvalidated copy of the entity if revalidation fails.<li><p>Although this is not recommended, user agents operating under severe connectivity constraints MAY violate this directive but, if so, MUST explicitly warn the user that an unvalidated response has been provided. The warning MUST be provided on each unvalidated access, and SHOULD require explicit user confirmation.<li><p>proxy-revalidate<p>The proxy-revalidate directive has the same meaning as the must- revalidate directive, except that it does not apply to non-shared user agent caches. It can be used on a response to an authenticated request to permit the user’s cache to store and later return the response without needing to revalidate it (since it has already been authenticated once by that user), while still requiring proxies that service many users to revalidate each time (in order to make sure that each user has been authenticated). Note that such authenticated responses also need the public cache control directive in order to allow them to be cached at all.</ul><h3 id="14-9-5-No-Transform-Directive">14.9.5 No-Transform Directive</h3><ul><li><p>no-transform<p>Implementors of intermediate caches (proxies) have found it useful to convert the media type of certain entity bodies. A non- transparent proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link.<li><p>Serious operational problems occur, however, when these transformations are applied to entity bodies intended for certain kinds of applications. For example, applications for medical<li><p>imaging, scientific data analysis and those using end-to-end authentication, all depend on receiving an entity body that is bit for bit identical to the original entity-body.<li><p>Therefore, if a message includes the no-transform directive, an intermediate cache or proxy MUST NOT change those headers that are listed in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.2" target="_blank" rel="noopener">13.5.2</a> as being subject to the no-transform directive. This implies that the cache or proxy MUST NOT change any aspect of the entity-body that is specified by these headers, including the value of the entity-body itself.</ul><h3 id="14-9-6-Cache-Control-Extensions">14.9.6 Cache Control Extensions</h3><p>The Cache-Control header field can be extended through the use of one or more cache-extension tokens, each with an optional assigned value. Informational extensions (those which do not require a change in cache behavior) MAY be added without changing the semantics of other directives. Behavioral extensions are designed to work by acting as modifiers to the existing base of cache directives. Both the new directive and the standard directive are supplied, such that applications which do not understand the new directive will default to the behavior specified by the standard directive, and those that understand the new directive will recognize it as modifying the requirements associated with the standard directive. In this way, extensions to the cache-control directives can be made without requiring changes to the base protocol.<p>This extension mechanism depends on an HTTP cache obeying all of the cache-control directives defined for its native HTTP-version, obeying certain extensions, and ignoring all directives that it does not understand.<p>For example, consider a hypothetical new response directive called community which acts as a modifier to the private directive. We define this new directive to mean that, in addition to any non-shared cache, any cache which is shared only by members of the community named within its value may cache the response. An origin server wishing to allow the UCI community to use an otherwise private response in their shared cache(s) could do so by including<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Cache-Control: private, community=&quot;UCI&quot;</span><br></pre></table></figure><p>A cache seeing this header field will act correctly even if the cache does not understand the community cache-extension, since it will also see and understand the private directive and thus default to the safe behavior.<p>Unrecognized cache-directives MUST be ignored; it is assumed that any cache-directive likely to be unrecognized by an HTTP/1.1 cache will be combined with standard directives (or the response’s default cacheability) such that the cache behavior will remain minimally correct even if the cache does not understand the extension(s).<h3 id="14-10-Connection">14.10 Connection</h3><p>The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections.<p>The Connection header has the following grammar:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)</span><br><span class="line">connection-token  = token</span><br></pre></table></figure><p>HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option.<p>Message headers listed in the Connection header MUST NOT include end-to-end headers, such as Cache-Control.<p>HTTP/1.1 defines the “close” connection option for the sender to signal that the connection will be closed after completion of the response. For example,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Connection: close</span><br></pre></table></figure><p>in either the request or the response header fields indicates that the connection SHOULD NOT be considered `persistent’ (section 8.1) after the current request/response is complete.<p>HTTP/1.1 applications that do not support persistent connections MUST include the “close” connection option in every message.<p>A system receiving an HTTP/1.0 (or lower-version) message that includes a Connection header MUST, for each connection-token in this field, remove and ignore any header field(s) from the message with the same name as the connection-token. This protects against mistaken forwarding of such header fields by pre-HTTP/1.1 proxies. See section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.6.2" target="_blank" rel="noopener">19.6.2</a>.<h3 id="14-11-Content-Encoding">14.11 Content-Encoding</h3><p>The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a document to be compressed without losing the identity of its underlying media type.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding</span><br></pre></table></figure><p>Content codings are defined in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5" target="_blank" rel="noopener">3.5</a>. An example of its use is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></table></figure><p>The content-coding is a characteristic of the entity identified by the Request-URI. Typically, the entity-body is stored with this encoding and is only decoded before rendering or analogous usage. However, a non-transparent proxy MAY modify the content-coding if the new coding is known to be acceptable to the recipient, unless the “no-transform” cache-control directive is present in the message.<p>If the content-coding of an entity is not “identity”, then the response MUST include a Content-Encoding entity-header (section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11" target="_blank" rel="noopener">14.11</a>) that lists the non-identity content-coding(s) used.<p>If the content-coding of an entity in a request message is not acceptable to the origin server, the server SHOULD respond with a status code of 415 (Unsupported Media Type).<p>If multiple encodings have been applied to an entity, the content codings MUST be listed in the order in which they were applied. Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.<h3 id="14-12-Content-Language">14.12 Content-Language</h3><p>The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag</span><br></pre></table></figure><p>Language tags are defined in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.10" target="_blank" rel="noopener">3.10</a>. The primary purpose of Content-Language is to allow a user to identify and differentiate entities according to the user’s own preferred language. Thus, if the body content is intended only for a Danish-literate audience, the appropriate field is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Content-Language: da</span><br></pre></table></figure><p>If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.<p>Multiple languages MAY be listed for content that is intended for multiple audiences. For example, a rendition of the “Treaty of Waitangi,” presented simultaneously in the original Maori and English versions, would call for<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Content-Language: mi, en</span><br></pre></table></figure><p>However, just because multiple languages are present within an entity does not mean that it is intended for multiple linguistic audiences. An example would be a beginner’s language primer, such as “A First Lesson in Latin,” which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include “en”.<p>Content-Language MAY be applied to any media type – it is not limited to textual documents.<h3 id="14-13-Content-Length">14.13 Content-Length</h3><p>The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT</span><br></pre></table></figure><p>An example is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></table></figure><p>Applications SHOULD use this field to indicate the transfer-length of the message-body, unless this is prohibited by the rules in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4" target="_blank" rel="noopener">4.4</a>.<p>Any Content-Length greater than or equal to zero is a valid value. Section 4.4 describes how to determine the length of a message-body if a Content-Length is not given.<p>Note that the meaning of this field is significantly different from the corresponding definition in MIME, where it is an optional field used within the “message/external-body” content-type. In HTTP, it SHOULD be sent whenever the message’s length can be determined prior to being transferred, unless this is prohibited by the rules in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4" target="_blank" rel="noopener">4.4</a>.<h3 id="14-14-Content-Location">14.14 Content-Location</h3><p>The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource’s URI. A server SHOULD provide a Content-Location for the variant corresponding to the response entity; especially in the case where a resource has multiple entities associated with it, and those entities actually have separate locations by which they might be individually accessed, the server SHOULD provide a Content-Location for the particular variant which is returned.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">Content-Location = &quot;Content-Location&quot; &quot;:&quot;</span><br><span class="line">                  ( absoluteURI | relativeURI )</span><br></pre></table></figure><p>The value of Content-Location also defines the base URI for the entity.<p>The Content-Location value is not a replacement for the original requested URI; it is only a statement of the location of the resource corresponding to this particular entity at the time of the request. Future requests MAY specify the Content-Location URI as the request- URI if the desire is to identify the source of that particular entity.<p>A cache cannot assume that an entity with a Content-Location different from the URI used to retrieve it can be used to respond to later requests on that Content-Location URI. However, the Content- Location can be used to differentiate between multiple entities retrieved from a single requested resource, as described in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.6" target="_blank" rel="noopener">13.6</a>.<p>If the Content-Location is a relative URI, the relative URI is interpreted relative to the Request-URI.<p>The meaning of the Content-Location header in PUT or POST requests is undefined; servers are free to ignore it in those cases.<h3 id="14-15-Content-MD5">14.15 Content-MD5</h3><p>The Content-MD5 entity-header field, as defined in RFC 1864 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib23" target="_blank" rel="noopener">[23]</a>, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest</span><br><span class="line">md5-digest   = &lt;base64 of 128 bit MD5 digest as per RFC 1864&gt;</span><br></pre></table></figure><p>The Content-MD5 header field MAY be generated by an origin server or client to function as an integrity check of the entity-body. Only origin servers or clients MAY generate the Content-MD5 header field; proxies and gateways MUST NOT generate it, as this would defeat its value as an end-to-end integrity check. Any recipient of the entity- body, including gateways and proxies, MAY check that the digest value in this header field matches that of the entity-body as received.<p>The MD5 digest is computed based on the content of the entity-body, including any content-coding that has been applied, but not including any transfer-encoding applied to the message-body. If the message is received with a transfer-encoding, that encoding MUST be removed prior to checking the Content-MD5 value against the received entity.<p>This has the result that the digest is computed on the octets of the entity-body exactly as, and in the order that, they would be sent if no transfer-encoding were being applied.<p>HTTP extends RFC 1864 to permit the digest to be computed for MIME composite media-types (e.g., multipart/* and message/rfc822), but this does not change how the digest is computed as defined in the preceding paragraph.<p>There are several consequences of this. The entity-body for composite types MAY contain many body-parts, each with its own MIME and HTTP headers (including Content-MD5, Content-Transfer-Encoding, and Content-Encoding headers). If a body-part has a Content-Transfer- Encoding or Content-Encoding header, it is assumed that the content of the body-part has had the encoding applied, and the body-part is included in the Content-MD5 digest as is – i.e., after the application. The Transfer-Encoding header field is not allowed within body-parts.<p>Conversion of all line breaks to CRLF MUST NOT be done before computing or checking the digest: the line break convention used in the text actually transmitted MUST be left unaltered when computing the digest.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre><td class="code"><pre><span class="line">Note: while the definition of Content-MD5 is exactly the same for</span><br><span class="line">HTTP as in RFC 1864 for MIME entity-bodies, there are several ways</span><br><span class="line">in which the application of Content-MD5 to HTTP entity-bodies</span><br><span class="line">differs from its application to MIME entity-bodies. One is that</span><br><span class="line">HTTP, unlike MIME, does not use Content-Transfer-Encoding, and</span><br><span class="line">does use Transfer-Encoding and Content-Encoding. Another is that</span><br><span class="line">HTTP more frequently uses binary content types than MIME, so it is</span><br><span class="line">worth noting that, in such cases, the byte order used to compute</span><br><span class="line">the digest is the transmission byte order defined for the type.</span><br><span class="line">Lastly, HTTP allows transmission of text types with any of several</span><br><span class="line">line break conventions and not just the canonical form using CRLF.</span><br></pre></table></figure><h3 id="14-16-Content-Range">14.16 Content-Range</h3><p>The Content-Range entity-header is sent with a partial entity-body to specify where in the full entity-body the partial body should be applied. Range units are defined in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.12" target="_blank" rel="noopener">3.12</a>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre><td class="code"><pre><span class="line">Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec</span><br><span class="line">content-range-spec      = byte-content-range-spec</span><br><span class="line">byte-content-range-spec = bytes-unit SP</span><br><span class="line">                          byte-range-resp-spec &quot;/&quot;</span><br><span class="line">                          ( instance-length | &quot;*&quot; )</span><br><span class="line">byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)</span><br><span class="line">                               | &quot;*&quot;</span><br><span class="line">instance-length           = 1*DIGIT</span><br></pre></table></figure><p>The header SHOULD indicate the total length of the full entity-body, unless this length is unknown or difficult to determine. The asterisk “*” character means that the instance-length is unknown at the time when the response was generated.<p>Unlike byte-ranges-specifier values (see section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1" target="_blank" rel="noopener">14.35.1</a>), a byte- range-resp-spec MUST only specify one range, and MUST contain absolute byte positions for both the first and last byte of the range.<p>A byte-content-range-spec with a byte-range-resp-spec whose last- byte-pos value is less than its first-byte-pos value, or whose instance-length value is less than or equal to its last-byte-pos value, is invalid. The recipient of an invalid byte-content-range- spec MUST ignore it and any content transferred along with it.<p>A server sending a response with status code 416 (Requested range not satisfiable) SHOULD include a Content-Range field with a byte-range- resp-spec of “*”. The instance-length specifies the current length of<p>the selected resource. A response with status code 206 (Partial Content) MUST NOT include a Content-Range field with a byte-range- resp-spec of “*”.<p>Examples of byte-content-range-spec values, assuming that the entity contains a total of 1234 bytes:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre><td class="code"><pre><span class="line">. The first 500 bytes:</span><br><span class="line"> bytes 0-499/1234</span><br><span class="line">. The second 500 bytes:</span><br><span class="line"> bytes 500-999/1234</span><br><span class="line">. All except for the first 500 bytes:</span><br><span class="line"> bytes 500-1233/1234</span><br><span class="line">. The last 500 bytes:</span><br><span class="line"> bytes 734-1233/1234</span><br></pre></table></figure><p>When an HTTP message includes the content of a single range (for example, a response to a request for a single range, or to a request for a set of ranges that overlap without any holes), this content is transmitted with a Content-Range header, and a Content-Length header showing the number of bytes actually transferred. For example,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre><td class="code"><pre><span class="line">HTTP/1.1 206 Partial content</span><br><span class="line">Date: Wed, 15 Nov 1995 06:25:24 GMT</span><br><span class="line">Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT</span><br><span class="line">Content-Range: bytes 21010-47021/47022</span><br><span class="line">Content-Length: 26012</span><br><span class="line">Content-Type: image/gif</span><br></pre></table></figure><p>When an HTTP message includes the content of multiple ranges (for example, a response to a request for multiple non-overlapping ranges), these are transmitted as a multipart message. The multipart media type used for this purpose is “multipart/byteranges” as defined in appendix <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.2" target="_blank" rel="noopener">19.2</a>. See appendix <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.6.3" target="_blank" rel="noopener">19.6.3</a> for a compatibility issue.<p>A response to a request for a single range MUST NOT be sent using the multipart/byteranges media type. A response to a request for multiple ranges, whose result is a single range, MAY be sent as a multipart/byteranges media type with one part. A client that cannot decode a multipart/byteranges message MUST NOT ask for multiple byte-ranges in a single request.<p>When a client requests multiple byte-ranges in one request, the server SHOULD return them in the order that they appeared in the request.<p>If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist. (Normally, this means return a 200 response containing the full entity).<p>If the server receives a request (other than one including an If- Range request-header field) with an unsatisfiable Range request- header field (that is, all of whose byte-range-spec values have a first-byte-pos value greater than the current length of the selected resource), it SHOULD return a response code of 416 (Requested range not satisfiable) (section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.17" target="_blank" rel="noopener">10.4.17</a>).<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre><td class="code"><pre><span class="line">Note: clients cannot depend on servers to send a 416 (Requested</span><br><span class="line">range not satisfiable) response instead of a 200 (OK) response for</span><br><span class="line">an unsatisfiable Range request-header, since not all servers</span><br><span class="line">implement this request-header.</span><br></pre></table></figure><h3 id="14-17-Content-Type">14.17 Content-Type</h3><p>The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type</span><br></pre></table></figure><p>Media types are defined in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7" target="_blank" rel="noopener">3.7</a>. An example of the field is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Content-Type: text/html; charset=ISO-8859-4</span><br></pre></table></figure><p>Further discussion of methods for identifying the media type of an entity is provided in section 7.2.1.<h3 id="14-18-Date">14.18 Date</h3><p>The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. The field value is an HTTP-date, as described in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1" target="_blank" rel="noopener">3.3.1</a>; it MUST be sent in RFC 1123 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib8" target="_blank" rel="noopener">[8]</a>-date format.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Date  = &quot;Date&quot; &quot;:&quot; HTTP-date</span><br></pre></table></figure><p>An example is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Date: Tue, 15 Nov 1994 08:12:31 GMT</span><br></pre></table></figure><p>Origin servers MUST include a Date header field in all responses, except in these cases:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre><td class="code"><pre><span class="line">1. If the response status code is 100 (Continue) or 101 (Switching</span><br><span class="line">   Protocols), the response MAY include a Date header field, at</span><br><span class="line">   the server&apos;s option.</span><br><span class="line">2. If the response status code conveys a server error, e.g. 500</span><br><span class="line">   (Internal Server Error) or 503 (Service Unavailable), and it is</span><br><span class="line">   inconvenient or impossible to generate a valid Date.</span><br><span class="line">3. If the server does not have a clock that can provide a</span><br><span class="line">   reasonable approximation of the current time, its responses</span><br><span class="line">   MUST NOT include a Date header field. In this case, the rules</span><br><span class="line">   in section 14.18.1 MUST be followed.</span><br></pre></table></figure><p>A received message that does not have a Date header field MUST be assigned one by the recipient if the message will be cached by that recipient or gatewayed via a protocol which requires a Date. An HTTP implementation without a clock MUST NOT cache responses without revalidating them on every use. An HTTP cache, especially a shared cache, SHOULD use a mechanism, such as NTP <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib28" target="_blank" rel="noopener">[28]</a>, to synchronize its clock with a reliable external standard.<p>Clients SHOULD only send a Date header field in messages that include an entity-body, as in the case of the PUT and POST requests, and even then it is optional. A client without a clock MUST NOT send a Date header field in a request.<p>The HTTP-date sent in a Date header SHOULD NOT represent a date and time subsequent to the generation of the message. It SHOULD represent the best available approximation of the date and time of message generation, unless the implementation has no means of generating a reasonably accurate date and time. In theory, the date ought to represent the moment just before the entity is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic value.<h3 id="14-18-1-Clockless-Origin-Server-Operation">14.18.1 Clockless Origin Server Operation</h3><p>Some origin server implementations might not have a clock available. An origin server without a clock MUST NOT assign Expires or Last- Modified values to a response, unless these values were associated with the resource by a system or user with a reliable clock. It MAY assign an Expires value that is known, at or before server configuration time, to be in the past (this allows “pre-expiration” of responses without storing separate Expires values for each resource).<h3 id="14-19-ETag">14.19 ETag</h3><p>The ETag response-header field provides the current value of the entity tag for the requested variant. The headers used with entity tags are described in sections <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.24" target="_blank" rel="noopener">14.24</a>, <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26" target="_blank" rel="noopener">14.26</a> and <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44" target="_blank" rel="noopener">14.44</a>. The entity tag MAY be used for comparison with other entities from the same resource (see section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.3" target="_blank" rel="noopener">13.3.3</a>).<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">ETag = &quot;ETag&quot; &quot;:&quot; entity-tag</span><br></pre></table></figure><p>Examples:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line">ETag: &quot;xyzzy&quot;</span><br><span class="line">ETag: W/&quot;xyzzy&quot;</span><br><span class="line">ETag: &quot;&quot;</span><br></pre></table></figure><h3 id="14-20-Expect">14.20 Expect</h3><p>The Expect request-header field is used to indicate that particular server behaviors are required by the client.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre><td class="code"><pre><span class="line">Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation</span><br><span class="line">expectation  =  &quot;100-continue&quot; | expectation-extension</span><br><span class="line">expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )</span><br><span class="line">                         *expect-params ]</span><br><span class="line">expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]</span><br></pre></table></figure><p>A server that does not understand or is unable to comply with any of the expectation values in the Expect field of a request MUST respond with appropriate error status. The server MUST respond with a 417 (Expectation Failed) status if any of the expectations cannot be met or, if there are other problems with the request, some other 4xx status.<p>This header field is defined with extensible syntax to allow for future extensions. If a server receives a request containing an Expect field that includes an expectation-extension that it does not support, it MUST respond with a 417 (Expectation Failed) status.<p>Comparison of expectation values is case-insensitive for unquoted tokens (including the 100-continue token), and is case-sensitive for quoted-string expectation-extensions.<p>The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST return a 417 (Expectation Failed) status if it receives a request with an expectation that it cannot meet. However, the Expect request-header itself is end-to-end; it MUST be forwarded if the request is forwarded.<p>Many older HTTP/1.0 and HTTP/1.1 applications do not understand the Expect header.<p>See section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3" target="_blank" rel="noopener">8.2.3</a> for the use of the 100 (continue) status.<h3 id="14-21-Expires">14.21 Expires</h3><p>The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache (either a proxy cache or a user agent cache) unless it is first validated with the origin server (or with an intermediate cache that has a fresh copy of the entity). See section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.2" target="_blank" rel="noopener">13.2</a> for further discussion of the expiration model.<p>The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time.<p>The format is an absolute date and time as defined by HTTP-date in section 3.3.1; it MUST be in RFC 1123 date format:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date</span><br></pre></table></figure><p>An example of its use is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre><td class="code"><pre><span class="line">Expires: Thu, 01 Dec 1994 16:00:00 GMT</span><br><span class="line">Note: if a response includes a Cache-Control field with the max-</span><br><span class="line">age directive (see section 14.9.3), that directive overrides the</span><br><span class="line">Expires field.</span><br></pre></table></figure><p>HTTP/1.1 clients and caches MUST treat other invalid date formats, especially including the value “0”, as in the past (i.e., “already expired”).<p>To mark a response as “already expired,” an origin server sends an Expires date that is equal to the Date header value. (See the rules for expiration calculations in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.2.4" target="_blank" rel="noopener">13.2.4</a>.)<p>To mark a response as “never expires,” an origin server sends an Expires date approximately one year from the time the response is sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future.<p>The presence of an Expires header field with a date value of some time in the future on a response that otherwise would by default be non-cacheable indicates that the response is cacheable, unless indicated otherwise by a Cache-Control header field (section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" target="_blank" rel="noopener">14.9</a>).<h3 id="14-22-From">14.22 From</h3><p>The From request-header field, if given, SHOULD contain an Internet e-mail address for the human user who controls the requesting user agent. The address SHOULD be machine-usable, as defined by “mailbox” in RFC 822 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib9" target="_blank" rel="noopener">[9]</a> as updated by RFC 1123 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib8" target="_blank" rel="noopener">[8]</a>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">From   = &quot;From&quot; &quot;:&quot; mailbox</span><br></pre></table></figure><p>An example is:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">From: webmaster@w3.org</span><br></pre></table></figure><p>This header field MAY be used for logging purposes and as a means for identifying the source of invalid or unwanted requests. It SHOULD NOT be used as an insecure form of access protection. The interpretation of this field is that the request is being performed on behalf of the person given, who accepts responsibility for the method performed. In particular, robot agents SHOULD include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving end.<p>The Internet e-mail address in this field MAY be separate from the Internet host which issued the request. For example, when a request is passed through a proxy the original issuer’s address SHOULD be used.<p>The client SHOULD NOT send the From header field without the user’s approval, as it might conflict with the user’s privacy interests or their site’s security policy. It is strongly recommended that the user be able to disable, enable, and modify the value of this field at any time prior to a request.<h3 id="14-23-Host">14.23 Host</h3><p>The Host request-header field specifies the Internet host and port number of the resource being requested, as obtained from the original URI given by the user or referring resource (generally an HTTP URL,<p>as described in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.2" target="_blank" rel="noopener">3.2.2</a>). The Host field value MUST represent the naming authority of the origin server or gateway given by the original URL. This allows the origin server or gateway to differentiate between internally-ambiguous URLs, such as the root “/“ URL of a server for multiple host names on a single IP address.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; Section 3.2.2</span><br></pre></table></figure><p>A “host” without any trailing port information implies the default port for the service requested (e.g., “80” for an HTTP URL). For example, a request on the origin server for <a href="http://www.w3.org/pub/WWW/" target="_blank" rel="noopener">http://www.w3.org/pub/WWW/</a> would properly include:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">GET /pub/WWW/ HTTP/1.1</span><br><span class="line">Host: www.w3.org</span><br></pre></table></figure><p>A client MUST include a Host header field in all HTTP/1.1 request messages . If the requested URI does not include an Internet host name for the service being requested, then the Host header field MUST be given with an empty value. An HTTP/1.1 proxy MUST ensure that any request message it forwards does contain an appropriate Host header field that identifies the service being requested by the proxy. All Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message which lacks a Host header field.<p>See sections <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.2" target="_blank" rel="noopener">5.2</a> and <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.6.1.1" target="_blank" rel="noopener">19.6.1.1</a> for other requirements relating to Host.<h3 id="14-24-If-Match">14.24 If-Match</h3><p>The If-Match request-header field is used with a method to make it conditional. A client that has one or more entities previously obtained from the resource can verify that one of those entities is current by including a list of their associated entity tags in the If-Match header field. Entity tags are defined in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.11" target="_blank" rel="noopener">3.11</a>. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. It is also used, on updating requests, to prevent inadvertent modification of the wrong version of a resource. As a special case, the value “*” matches any current entity of the resource.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )</span><br></pre></table></figure><p>If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-Match header) on that resource, or if “*” is given<p>and any current entity exists for that resource, then the server MAY perform the requested method as if the If-Match header field did not exist.<p>A server MUST use the strong comparison function (see section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.3" target="_blank" rel="noopener">13.3.3</a>) to compare the entity tags in If-Match.<p>If none of the entity tags match, or if “*” is given and no current entity exists, the server MUST NOT perform the requested method, and MUST return a 412 (Precondition Failed) response. This behavior is most useful when the client wants to prevent an updating method, such as PUT, from modifying a resource that has changed since the client last retrieved it.<p>If the request would, without the If-Match header field, result in anything other than a 2xx or 412 status, then the If-Match header MUST be ignored.<p>The meaning of “If-Match: *” is that the method SHOULD be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44" target="_blank" rel="noopener">14.44</a>) exists, and MUST NOT be performed if the representation does not exist.<p>A request intended to update a resource (e.g., a PUT) MAY include an If-Match header field to signal that the request method MUST NOT be applied if the entity corresponding to the If-Match value (a single entity tag) is no longer a representation of that resource. This allows the user to indicate that they do not wish the request to be successful if the resource has been changed without their knowledge. Examples:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line">If-Match: &quot;xyzzy&quot;</span><br><span class="line">If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;</span><br><span class="line">If-Match: *</span><br></pre></table></figure><p>The result of a request having both an If-Match header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification.<h3 id="14-25-If-Modified-Since">14.25 If-Modified-Since</h3><p>The If-Modified-Since request-header field is used with a method to make it conditional: if the requested variant has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date</span><br></pre></table></figure><p>An example of the field is:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</span><br></pre></table></figure><p>A GET method with an If-Modified-Since header and no Range header requests that the identified entity be transferred only if it has been modified since the date given by the If-Modified-Since header. The algorithm for determining this includes the following cases:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre><td class="code"><pre><span class="line">a) If the request would normally result in anything other than a</span><br><span class="line">   200 (OK) status, or if the passed If-Modified-Since date is</span><br><span class="line">   invalid, the response is exactly the same as for a normal GET.</span><br><span class="line">   A date which is later than the server&apos;s current time is</span><br><span class="line">   invalid.</span><br><span class="line">b) If the variant has been modified since the If-Modified-Since</span><br><span class="line">   date, the response is exactly the same as for a normal GET.</span><br><span class="line">c) If the variant has not been modified since a valid If-</span><br><span class="line">   Modified-Since date, the server SHOULD return a 304 (Not</span><br><span class="line">   Modified) response.</span><br></pre></table></figure><p>The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre><td class="code"><pre><span class="line">Note: The Range request-header field modifies the meaning of If-</span><br><span class="line">Modified-Since; see section 14.35 for full details.</span><br><span class="line">Note: If-Modified-Since times are interpreted by the server, whose</span><br><span class="line">clock might not be synchronized with the client.</span><br><span class="line">Note: When handling an If-Modified-Since header field, some</span><br><span class="line">servers will use an exact date comparison function, rather than a</span><br><span class="line">less-than function, for deciding whether to send a 304 (Not</span><br><span class="line">Modified) response. To get best results when sending an If-</span><br><span class="line">Modified-Since header field for cache validation, clients are</span><br><span class="line">advised to use the exact date string received in a previous Last-</span><br><span class="line">Modified header field whenever possible.</span><br><span class="line">Note: If a client uses an arbitrary date in the If-Modified-Since</span><br><span class="line">header instead of a date taken from the Last-Modified header for</span><br><span class="line">the same request, the client should be aware of the fact that this</span><br><span class="line">date is interpreted in the server&apos;s understanding of time. The</span><br><span class="line">client should consider unsynchronized clocks and rounding problems</span><br><span class="line">due to the different encodings of time between the client and</span><br><span class="line">server. This includes the possibility of race conditions if the</span><br><span class="line">document has changed between the time it was first requested and</span><br><span class="line">the If-Modified-Since date of a subsequent request, and the</span><br><span class="line">possibility of clock-skew-related problems if the If-Modified-</span><br><span class="line">Since date is derived from the client&apos;s clock without correction</span><br><span class="line">to the server&apos;s clock. Corrections for different time bases</span><br><span class="line">between client and server are at best approximate due to network</span><br><span class="line">latency.</span><br></pre></table></figure><p>The result of a request having both an If-Modified-Since header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification.<h3 id="14-26-If-None-Match">14.26 If-None-Match</h3><p>The If-None-Match request-header field is used with a method to make it conditional. A client that has one or more entities previously obtained from the resource can verify that none of those entities is current by including a list of their associated entity tags in the If-None-Match header field. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. It is also used to prevent a method (e.g. PUT) from inadvertently modifying an existing resource when the client believes that the resource does not exist.<p>As a special case, the value “*” matches any current entity of the resource.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )</span><br></pre></table></figure><p>If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-None-Match header) on that resource, or if “*” is given and any current entity exists for that resource, then the server MUST NOT perform the requested method, unless required to do so because the resource’s modification date fails to match that supplied in an If-Modified-Since header field in the request. Instead, if the request method was GET or HEAD, the server SHOULD respond with a 304 (Not Modified) response, including the cache- related header fields (particularly ETag) of one of the entities that matched. For all other request methods, the server MUST respond with a status of 412 (Precondition Failed).<p>See section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.3" target="_blank" rel="noopener">13.3.3</a> for rules on how to determine if two entities tags match. The weak comparison function can only be used with GET or HEAD requests.<p>If none of the entity tags match, then the server MAY perform the requested method as if the If-None-Match header field did not exist, but MUST also ignore any If-Modified-Since header field(s) in the request. That is, if no entity tags match, then the server MUST NOT return a 304 (Not Modified) response.<p>If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the If-None-Match header MUST be ignored. (See section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4" target="_blank" rel="noopener">13.3.4</a> for a discussion of server behavior when both If-Modified-Since and If-None-Match appear in the same request.)<p>The meaning of “If-None-Match: *” is that the method MUST NOT be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44" target="_blank" rel="noopener">14.44</a>) exists, and SHOULD be performed if the representation does not exist. This feature is intended to be useful in preventing races between PUT operations.<p>Examples:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre><td class="code"><pre><span class="line">If-None-Match: &quot;xyzzy&quot;</span><br><span class="line">If-None-Match: W/&quot;xyzzy&quot;</span><br><span class="line">If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;</span><br><span class="line">If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;</span><br><span class="line">If-None-Match: *</span><br></pre></table></figure><p>The result of a request having both an If-None-Match header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification.<h3 id="14-27-If-Range">14.27 If-Range</h3><p>If a client has a partial copy of an entity in its cache, and wishes to have an up-to-date copy of the entire entity in its cache, it could use the Range request-header with a conditional GET (using either or both of If-Unmodified-Since and If-Match.) However, if the condition fails because the entity has been modified, the client would then have to make a second request to obtain the entire current entity-body.<p>The If-Range header allows a client to “short-circuit” the second request. Informally, its meaning is `if the entity is unchanged, send me the part(s) that I am missing; otherwise, send me the entire new entity’.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date )</span><br></pre></table></figure><p>If the client has no entity tag for an entity, but does have a Last- Modified date, it MAY use that date in an If-Range header. (The server can distinguish between a valid HTTP-date and any form of entity-tag by examining no more than two characters.) The If-Range header SHOULD only be used together with a Range header, and MUST be ignored if the request does not include a Range header, or if the server does not support the sub-range operation.<p>If the entity tag given in the If-Range header matches the current entity tag for the entity, then the server SHOULD provide the specified sub-range of the entity using a 206 (Partial content) response. If the entity tag does not match, then the server SHOULD return the entire entity using a 200 (OK) response.<h3 id="14-28-If-Unmodified-Since">14.28 If-Unmodified-Since</h3><p>The If-Unmodified-Since request-header field is used with a method to make it conditional. If the requested resource has not been modified since the time specified in this field, the server SHOULD perform the requested operation as if the If-Unmodified-Since header were not present.<p>If the requested variant has been modified since the specified time, the server MUST NOT perform the requested operation, and MUST return a 412 (Precondition Failed).<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date</span><br></pre></table></figure><p>An example of the field is:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</span><br></pre></table></figure><p>If the request normally (i.e., without the If-Unmodified-Since header) would result in anything other than a 2xx or 412 status, the If-Unmodified-Since header SHOULD be ignored.<p>If the specified date is invalid, the header is ignored.<p>The result of a request having both an If-Unmodified-Since header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification.<h3 id="14-29-Last-Modified">14.29 Last-Modified</h3><p>The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date</span><br></pre></table></figure><p>An example of its use is<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</span><br></pre></table></figure><p>The exact meaning of this header field depends on the implementation of the origin server and the nature of the original resource. For files, it may be just the file system last-modified time. For entities with dynamically included parts, it may be the most recent of the set of last-modify times for its component parts. For database gateways, it may be the last-update time stamp of the record. For virtual objects, it may be the last time the internal state changed.<p>An origin server MUST NOT send a Last-Modified date which is later than the server’s time of message origination. In such cases, where the resource’s last modification would indicate some time in the future, the server MUST replace that date with the message origination date.<p>An origin server SHOULD obtain the Last-Modified value of the entity as close as possible to the time that it generates the Date value of its response. This allows a recipient to make an accurate assessment of the entity’s modification time, especially if the entity changes near the time that the response is generated.<p>HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.<h3 id="14-30-Location">14.30 Location</h3><p>The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. For 201 (Created) responses, the Location is that of the new resource which was created by the request. For 3xx responses, the location SHOULD indicate the server’s preferred URI for automatic redirection to the resource. The field value consists of a single absolute URI.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Location       = &quot;Location&quot; &quot;:&quot; absoluteURI</span><br></pre></table></figure><p>An example is:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre><td class="code"><pre><span class="line"> Location: http://www.w3.org/pub/WWW/People.html</span><br><span class="line">Note: The Content-Location header field (section 14.14) differs</span><br><span class="line">from Location in that the Content-Location identifies the original</span><br><span class="line">location of the entity enclosed in the request. It is therefore</span><br><span class="line">possible for a response to contain header fields for both Location</span><br><span class="line">and Content-Location. Also see section 13.10 for cache</span><br><span class="line">requirements of some methods.</span><br></pre></table></figure><h3 id="14-31-Max-Forwards">14.31 Max-Forwards</h3><p>The Max-Forwards request-header field provides a mechanism with the TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit the number of proxies or gateways that can forward the request to the next inbound server. This can be useful when the client is attempting to trace a request chain which appears to be failing or looping in mid-chain.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT</span><br></pre></table></figure><p>The Max-Forwards value is a decimal integer indicating the remaining number of times this request message may be forwarded.<p>Each proxy or gateway recipient of a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request. If the received value is zero (0), the recipient MUST NOT forward the request; instead, it MUST respond as the final recipient. If the received Max-Forwards value is greater than zero, then the forwarded message MUST contain an updated Max-Forwards field with a value decremented by one (1).<p>The Max-Forwards header field MAY be ignored for all other methods defined by this specification and for any extension methods for which it is not explicitly referred to as part of that method definition.<h3 id="14-32-Pragma">14.32 Pragma</h3><p>The Pragma general-header field is used to include implementation- specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line">Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive</span><br><span class="line">pragma-directive  = &quot;no-cache&quot; | extension-pragma</span><br><span class="line">extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]</span><br></pre></table></figure><p>When the no-cache directive is present in a request message, an application SHOULD forward the request toward the origin server even if it has a cached copy of what is being requested. This pragma directive has the same semantics as the no-cache cache-directive (see section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" target="_blank" rel="noopener">14.9</a>) and is defined here for backward compatibility with HTTP/1.0. Clients SHOULD include both header fields when a no-cache request is sent to a server not known to be HTTP/1.1 compliant.<p>Pragma directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient SHOULD be ignored by that recipient.<p>HTTP/1.1 caches SHOULD treat “Pragma: no-cache” as if the client had sent “Cache-Control: no-cache”. No new Pragma directives will be defined in HTTP.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line">Note: because the meaning of &quot;Pragma: no-cache as a response</span><br><span class="line">header field is not actually specified, it does not provide a</span><br><span class="line">reliable replacement for &quot;Cache-Control: no-cache&quot; in a response</span><br></pre></table></figure><h3 id="14-33-Proxy-Authenticate">14.33 Proxy-Authenticate</h3><p>The Proxy-Authenticate response-header field MUST be included as part of a 407 (Proxy Authentication Required) response. The field value consists of a challenge that indicates the authentication scheme and parameters applicable to the proxy for this Request-URI.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge</span><br></pre></table></figure><p>The HTTP access authentication process is described in “HTTP Authentication: Basic and Digest Access Authentication” [43]. Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the current connection and SHOULD NOT be passed on to downstream clients. However, an intermediate proxy might need to obtain its own credentials by requesting them from the downstream client, which in some circumstances will appear as if the proxy is forwarding the Proxy-Authenticate header field.<h3 id="14-34-Proxy-Authorization">14.34 Proxy-Authorization</h3><p>The Proxy-Authorization request-header field allows the client to identify itself (or its user) to a proxy which requires authentication. The Proxy-Authorization field value consists of credentials containing the authentication information of the user agent for the proxy and/or realm of the resource being requested.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials</span><br></pre></table></figure><p>The HTTP access authentication process is described in “HTTP Authentication: Basic and Digest Access Authentication” [43] . Unlike Authorization, the Proxy-Authorization header field applies only to the next outbound proxy that demanded authentication using the Proxy- Authenticate field. When multiple proxies are used in a chain, the<p>Proxy-Authorization header field is consumed by the first outbound proxy that was expecting to receive credentials. A proxy MAY relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively authenticate a given request.<h3 id="14-35-Range">14.35 Range</h3><h3 id="14-35-1-Byte-Ranges">14.35.1 Byte Ranges</h3><p>Since all HTTP entities are represented in HTTP messages as sequences of bytes, the concept of a byte range is meaningful for any HTTP entity. (However, not all clients and servers need to support byte- range operations.)<p>Byte range specifications in HTTP apply to the sequence of bytes in the entity-body (not necessarily the same as the message-body).<p>A byte range operation MAY specify a single range of bytes, or a set of ranges within a single entity.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre><td class="code"><pre><span class="line">ranges-specifier = byte-ranges-specifier</span><br><span class="line">byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set</span><br><span class="line">byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )</span><br><span class="line">byte-range-spec = first-byte-pos &quot;-&quot; [last-byte-pos]</span><br><span class="line">first-byte-pos  = 1*DIGIT</span><br><span class="line">last-byte-pos   = 1*DIGIT</span><br></pre></table></figure><p>The first-byte-pos value in a byte-range-spec gives the byte-offset of the first byte in a range. The last-byte-pos value gives the byte-offset of the last byte in the range; that is, the byte positions specified are inclusive. Byte offsets start at zero.<p>If the last-byte-pos value is present, it MUST be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte- range-spec is syntactically invalid. The recipient of a byte-range- set that includes one or more syntactically invalid byte-range-spec values MUST ignore the header field that includes that byte-range- set.<p>If the last-byte-pos value is absent, or if the value is greater than or equal to the current length of the entity-body, last-byte-pos is taken to be equal to one less than the current length of the entity- body in bytes.<p>By its choice of last-byte-pos, a client can limit the number of bytes retrieved without knowing the size of the entity.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">suffix-byte-range-spec = &quot;-&quot; suffix-length</span><br><span class="line">suffix-length = 1*DIGIT</span><br></pre></table></figure><p>A suffix-byte-range-spec is used to specify the suffix of the entity-body, of a length given by the suffix-length value. (That is, this form specifies the last N bytes of an entity-body.) If the entity is shorter than the specified suffix-length, the entire entity-body is used.<p>If a syntactically valid byte-range-set includes at least one byte- range-spec whose first-byte-pos is less than the current length of the entity-body, or at least one suffix-byte-range-spec with a non- zero suffix-length, then the byte-range-set is satisfiable. Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set is unsatisfiable, the server SHOULD return a response with a status of 416 (Requested range not satisfiable). Otherwise, the server SHOULD return a response with a status of 206 (Partial Content) containing the satisfiable ranges of the entity-body.<p>Examples of byte-ranges-specifier values (assuming an entity-body of length 10000):<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre><td class="code"><pre><span class="line">- The first 500 bytes (byte offsets 0-499, inclusive):  bytes=0-</span><br><span class="line">  499</span><br><span class="line">- The second 500 bytes (byte offsets 500-999, inclusive):</span><br><span class="line">  bytes=500-999</span><br><span class="line">- The final 500 bytes (byte offsets 9500-9999, inclusive):</span><br><span class="line">  bytes=-500</span><br><span class="line">- Or bytes=9500-</span><br><span class="line">- The first and last bytes only (bytes 0 and 9999):  bytes=0-0,-1</span><br><span class="line">- Several legal but not canonical specifications of the second 500</span><br><span class="line">  bytes (byte offsets 500-999, inclusive):</span><br><span class="line">   bytes=500-600,601-999</span><br><span class="line">   bytes=500-700,601-999</span><br></pre></table></figure><h3 id="14-35-2-Range-Retrieval-Requests">14.35.2 Range Retrieval Requests</h3><p>HTTP retrieval requests using conditional or unconditional GET methods MAY request one or more sub-ranges of the entity, instead of the entire entity, using the Range request header, which applies to the entity returned as the result of the request:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Range = &quot;Range&quot; &quot;:&quot; ranges-specifier</span><br></pre></table></figure><p>A server MAY ignore the Range header. However, HTTP/1.1 origin servers and intermediate caches ought to support byte ranges when possible, since Range supports efficient recovery from partially failed transfers, and supports efficient partial retrieval of large entities.<p>If the server supports the Range header and the specified range or ranges are appropriate for the entity:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre><td class="code"><pre><span class="line">- The presence of a Range header in an unconditional GET modifies</span><br><span class="line">  what is returned if the GET is otherwise successful. In other</span><br><span class="line">  words, the response carries a status code of 206 (Partial</span><br><span class="line">  Content) instead of 200 (OK).</span><br><span class="line">- The presence of a Range header in a conditional GET (a request</span><br><span class="line">  using one or both of If-Modified-Since and If-None-Match, or</span><br><span class="line">  one or both of If-Unmodified-Since and If-Match) modifies what</span><br><span class="line">  is returned if the GET is otherwise successful and the</span><br><span class="line">  condition is true. It does not affect the 304 (Not Modified)</span><br><span class="line">  response returned if the conditional is false.</span><br></pre></table></figure><p>In some cases, it might be more appropriate to use the If-Range header (see section 14.27) in addition to the Range header.<p>If a proxy that supports ranges receives a Range request, forwards the request to an inbound server, and receives an entire entity in reply, it SHOULD only return the requested range to its client. It SHOULD store the entire received response in its cache if that is consistent with its cache allocation policies.<h3 id="14-36-Referer">14.36 Referer</h3><p>The Referer[sic] request-header field allows the client to specify, for the server’s benefit, the address (URI) of the resource from which the Request-URI was obtained (the “referrer”, although the header field is misspelled.) The Referer request-header allows a server to generate lists of back-links to resources for interest, logging, optimized caching, etc. It also allows obsolete or mistyped links to be traced for maintenance. The Referer field MUST NOT be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )</span><br></pre></table></figure><p>Example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Referer: http://www.w3.org/hypertext/DataSources/Overview.html</span><br></pre></table></figure><p>If the field value is a relative URI, it SHOULD be interpreted relative to the Request-URI. The URI MUST NOT include a fragment. See section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3" target="_blank" rel="noopener">15.1.3</a> for security considerations.<h3 id="14-37-Retry-After">14.37 Retry-After</h3><p>The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. This field MAY also be used with any 3xx (Redirection) response to indicate the minimum time the user-agent is asked wait before issuing the redirected request. The value of this field can be either an HTTP-date or an integer number of seconds (in decimal) after the time of the response.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )</span><br></pre></table></figure><p>Two examples of its use are<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">Retry-After: Fri, 31 Dec 1999 23:59:59 GMT</span><br><span class="line">Retry-After: 120</span><br></pre></table></figure><p>In the latter example, the delay is 2 minutes.<h3 id="14-38-Server">14.38 Server</h3><p>The Server response-header field contains information about the software used by the origin server to handle the request. The field can contain multiple product tokens (section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.8" target="_blank" rel="noopener">3.8</a>) and comments identifying the server and any significant subproducts. The product tokens are listed in order of their significance for identifying the application.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )</span><br></pre></table></figure><p>Example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Server: CERN/3.0 libwww/2.17</span><br></pre></table></figure><p>If the response is being forwarded through a proxy, the proxy application MUST NOT modify the Server response-header. Instead, it SHOULD include a Via field (as described in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.45" target="_blank" rel="noopener">14.45</a>).<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre><td class="code"><pre><span class="line">Note: Revealing the specific software version of the server might</span><br><span class="line">allow the server machine to become more vulnerable to attacks</span><br><span class="line">against software that is known to contain security holes. Server</span><br><span class="line">implementors are encouraged to make this field a configurable</span><br><span class="line">option.</span><br></pre></table></figure><h3 id="14-39-TE">14.39 TE</h3><p>The TE request-header field indicates what extension transfer-codings it is willing to accept in the response and whether or not it is willing to accept trailer fields in a chunked transfer-coding. Its value may consist of the keyword “trailers” and/or a comma-separated list of extension transfer-coding names with optional accept parameters (as described in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6" target="_blank" rel="noopener">3.6</a>).<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre><td class="code"><pre><span class="line">TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )</span><br><span class="line">t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )</span><br></pre></table></figure><p>The presence of the keyword “trailers” indicates that the client is willing to accept trailer fields in a chunked transfer-coding, as defined in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1" target="_blank" rel="noopener">3.6.1</a>. This keyword is reserved for use with transfer-coding values even though it does not itself represent a transfer-coding.<p>Examples of its use are:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line">TE: deflate</span><br><span class="line">TE:</span><br><span class="line">TE: trailers, deflate;q=0.5</span><br></pre></table></figure><p>The TE header field only applies to the immediate connection. Therefore, the keyword MUST be supplied within a Connection header field (section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.10" target="_blank" rel="noopener">14.10</a>) whenever TE is present in an HTTP/1.1 message.<p>A server tests whether a transfer-coding is acceptable, according to a TE field, using these rules:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre><td class="code"><pre><span class="line">1. The &quot;chunked&quot; transfer-coding is always acceptable. If the</span><br><span class="line">   keyword &quot;trailers&quot; is listed, the client indicates that it is</span><br><span class="line">   willing to accept trailer fields in the chunked response on</span><br><span class="line">   behalf of itself and any downstream clients. The implication is</span><br><span class="line">   that, if given, the client is stating that either all</span><br><span class="line">   downstream clients are willing to accept trailer fields in the</span><br><span class="line">   forwarded response, or that it will attempt to buffer the</span><br><span class="line">   response on behalf of downstream recipients.</span><br><span class="line">   Note: HTTP/1.1 does not define any means to limit the size of a</span><br><span class="line">   chunked response such that a client can be assured of buffering</span><br><span class="line">   the entire response.</span><br><span class="line">2. If the transfer-coding being tested is one of the transfer-</span><br><span class="line">   codings listed in the TE field, then it is acceptable unless it</span><br><span class="line">   is accompanied by a qvalue of 0. (As defined in section 3.9, a</span><br><span class="line">   qvalue of 0 means &quot;not acceptable.&quot;)</span><br><span class="line">3. If multiple transfer-codings are acceptable, then the</span><br><span class="line">   acceptable transfer-coding with the highest non-zero qvalue is</span><br><span class="line">   preferred.  The &quot;chunked&quot; transfer-coding always has a qvalue</span><br><span class="line">   of 1.</span><br></pre></table></figure><p>If the TE field-value is empty or if no TE field is present, the only transfer-coding is “chunked”. A message with no transfer-coding is always acceptable.<h3 id="14-40-Trailer">14.40 Trailer</h3><p>The Trailer general field value indicates that the given set of header fields is present in the trailer of a message encoded with chunked transfer-coding.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name</span><br></pre></table></figure><p>An HTTP/1.1 message SHOULD include a Trailer header field in a message using chunked transfer-coding with a non-empty trailer. Doing so allows the recipient to know which header fields to expect in the trailer.<p>If no Trailer header field is present, the trailer SHOULD NOT include any header fields. See section 3.6.1 for restrictions on the use of trailer fields in a “chunked” transfer-coding.<p>Message header fields listed in the Trailer header field MUST NOT include the following header fields:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line">. Transfer-Encoding</span><br><span class="line">. Content-Length</span><br><span class="line">. Trailer</span><br></pre></table></figure><h3 id="14-41-Transfer-Encoding">14.41 Transfer-Encoding</h3><p>The Transfer-Encoding general-header field indicates what (if any) type of transformation has been applied to the message body in order to safely transfer it between the sender and the recipient. This differs from the content-coding in that the transfer-coding is a property of the message, not of the entity.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding</span><br></pre></table></figure><p>Transfer-codings are defined in section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6" target="_blank" rel="noopener">3.6</a>. An example is:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></table></figure><p>If multiple encodings have been applied to an entity, the transfer- codings MUST be listed in the order in which they were applied. Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.<p>Many older HTTP/1.0 applications do not understand the Transfer- Encoding header.<h3 id="14-42-Upgrade">14.42 Upgrade</h3><p>The Upgrade general-header allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols. The server MUST use the Upgrade header field within a 101 (Switching Protocols) response to indicate which protocol(s) are being switched.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Upgrade        = &quot;Upgrade&quot; &quot;:&quot; 1#product</span><br></pre></table></figure><p>For example,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</span><br></pre></table></figure><p>The Upgrade header field is intended to provide a simple mechanism for transition from HTTP/1.1 to some other, incompatible protocol. It does so by allowing the client to advertise its desire to use another protocol, such as a later version of HTTP with a higher major version number, even though the current request has been made using HTTP/1.1. This eases the difficult transition between incompatible protocols by allowing the client to initiate a request in the more commonly supported protocol while indicating to the server that it would like to use a “better” protocol if available (where “better” is determined by the server, possibly according to the nature of the method and/or resource being requested).<p>The Upgrade header field only applies to switching application-layer protocols upon the existing transport-layer connection. Upgrade cannot be used to insist on a protocol change; its acceptance and use by the server is optional. The capabilities and nature of the application-layer communication after the protocol change is entirely dependent upon the new protocol chosen, although the first action after changing the protocol MUST be a response to the initial HTTP request containing the Upgrade header field.<p>The Upgrade header field only applies to the immediate connection. Therefore, the upgrade keyword MUST be supplied within a Connection header field (section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.10" target="_blank" rel="noopener">14.10</a>) whenever Upgrade is present in an HTTP/1.1 message.<p>The Upgrade header field cannot be used to indicate a switch to a protocol on a different connection. For that purpose, it is more appropriate to use a 301, 302, 303, or 305 redirection response.<p>This specification only defines the protocol name “HTTP” for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.1" target="_blank" rel="noopener">3.1</a> and future updates to this specification. Any token can be used as a protocol name; however, it will only be useful if both the client and server associate the name with the same protocol.<h3 id="14-43-User-Agent">14.43 User-Agent</h3><p>The User-Agent request-header field contains information about the user agent originating the request. This is for statistical purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses to avoid particular user agent limitations. User agents SHOULD include this field with requests. The field can contain multiple product tokens (section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.8" target="_blank" rel="noopener">3.8</a>) and comments identifying the agent and any subproducts which form a significant part of the user agent. By convention, the product tokens are listed in order of their significance for identifying the application.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">User-Agent     = &quot;User-Agent&quot; &quot;:&quot; 1*( product | comment )</span><br></pre></table></figure><p>Example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">User-Agent: CERN-LineMode/2.15 libwww/2.17b3</span><br></pre></table></figure><h3 id="14-44-Vary">14.44 Vary</h3><p>The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. For uncacheable or stale responses, the Vary field value advises the user agent about the criteria that were used to select the representation. A Vary field value of “*” implies that a cache cannot determine from the request headers of a subsequent request whether this response is the appropriate representation. See section <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.6" target="_blank" rel="noopener">13.6</a> for use of the Vary header field by caches.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Vary  = &quot;Vary&quot; &quot;:&quot; ( &quot;*&quot; | 1#field-name )</span><br></pre></table></figure><p>An HTTP/1.1 server SHOULD include a Vary header field with any cacheable response that is subject to server-driven negotiation. Doing so allows a cache to properly interpret future requests on that resource and informs the user agent about the presence of negotiation<p>on that resource. A server MAY include a Vary header field with a non-cacheable response that is subject to server-driven negotiation, since this might provide the user agent with useful information about the dimensions over which the response varies at the time of the response.<p>A Vary field value consisting of a list of field-names signals that the representation selected for the response is based on a selection algorithm which considers ONLY the listed request-header field values in selecting the most appropriate representation. A cache MAY assume that the same selection will be made for future requests with the same values for the listed field names, for the duration of time for which the response is fresh.<p>The field-names given are not limited to the set of standard request-header fields defined by this specification. Field names are case-insensitive.<p>A Vary field value of “<em>“ signals that unspecified parameters not limited to the request-headers (e.g., the network address of the client), play a role in the selection of the response representation. The “</em>“ value MUST NOT be generated by a proxy server; it may only be generated by an origin server.<h3 id="14-45-Via">14.45 Via</h3><p>The Via general-header field MUST be used by gateways and proxies to indicate the intermediate protocols and recipients between the user agent and the server on requests, and between the origin server and the client on responses. It is analogous to the “Received” field of RFC 822 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib9" target="_blank" rel="noopener">[9]</a> and is intended to be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of all senders along the request/response chain.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre><td class="code"><pre><span class="line">Via =  &quot;Via&quot; &quot;:&quot; 1#( received-protocol received-by [ comment ] )</span><br><span class="line">received-protocol = [ protocol-name &quot;/&quot; ] protocol-version</span><br><span class="line">protocol-name     = token</span><br><span class="line">protocol-version  = token</span><br><span class="line">received-by       = ( host [ &quot;:&quot; port ] ) | pseudonym</span><br><span class="line">pseudonym         = token</span><br></pre></table></figure><p>The received-protocol indicates the protocol version of the message received by the server or client along each segment of the request/response chain. The received-protocol version is appended to the Via field value when the message is forwarded so that information about the protocol capabilities of upstream applications remains visible to all recipients.<p>The protocol-name is optional if and only if it would be “HTTP”. The received-by field is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, it MAY be replaced by a pseudonym. If the port is not given, it MAY be assumed to be the default port of the received-protocol.<p>Multiple Via field values represents each proxy or gateway that has forwarded the message. Each recipient MUST append its information such that the end result is ordered according to the sequence of forwarding applications.<p>Comments MAY be used in the Via header field to identify the software of the recipient proxy or gateway, analogous to the User-Agent and Server header fields. However, all comments in the Via field are optional and MAY be removed by any recipient prior to forwarding the message.<p>For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named “fred”, which uses HTTP/1.1 to forward the request to a public proxy at nowhere.com, which completes the request by forwarding it to the origin server at <a href="http://www.ics.uci.edu" target="_blank" rel="noopener">www.ics.uci.edu</a>. The request received by <a href="http://www.ics.uci.edu" target="_blank" rel="noopener">www.ics.uci.edu</a> would then have the following Via header field:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</span><br></pre></table></figure><p>Proxies and gateways used as a portal through a network firewall SHOULD NOT, by default, forward the names and ports of hosts within the firewall region. This information SHOULD only be propagated if explicitly enabled. If not enabled, the received-by host of any host behind the firewall SHOULD be replaced by an appropriate pseudonym for that host.<p>For organizations that have strong privacy requirements for hiding internal structures, a proxy MAY combine an ordered subsequence of Via header field entries with identical received-protocol values into a single such entry. For example,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre><td class="code"><pre><span class="line">Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy</span><br><span class="line"> could be collapsed to</span><br><span class="line">Via: 1.0 ricky, 1.1 mertz, 1.0 lucy</span><br></pre></table></figure><p>Applications SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms. Applications MUST NOT combine entries which have different received-protocol values.<h3 id="14-46-Warning">14.46 Warning</h3><p>The Warning general-header field is used to carry additional information about the status or transformation of a message which might not be reflected in the message. This information is typically used to warn about a possible lack of semantic transparency from caching operations or transformations applied to the entity body of the message.<p>Warning headers are sent with responses using:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre><td class="code"><pre><span class="line">Warning    = &quot;Warning&quot; &quot;:&quot; 1#warning-value</span><br><span class="line">warning-value = warn-code SP warn-agent SP warn-text</span><br><span class="line">                                      [SP warn-date]</span><br><span class="line">warn-code  = 3DIGIT</span><br><span class="line">warn-agent = ( host [ &quot;:&quot; port ] ) | pseudonym</span><br><span class="line">                ; the name or pseudonym of the server adding</span><br><span class="line">                ; the Warning header, for use in debugging</span><br><span class="line">warn-text  = quoted-string</span><br><span class="line">warn-date  = &lt;&quot;&gt; HTTP-date &lt;&quot;&gt;</span><br></pre></table></figure><p>A response MAY carry more than one Warning header.<p>The warn-text SHOULD be in a natural language and character set that is most likely to be intelligible to the human user receiving the response. This decision MAY be based on any available knowledge, such as the location of the cache or user, the Accept-Language field in a request, the Content-Language field in a response, etc. The default language is English and the default character set is ISO-8859-1.<p>If a character set other than ISO-8859-1 is used, it MUST be encoded in the warn-text using the method described in RFC 2047 [14].<p>Warning headers can in general be applied to any message, however some specific warn-codes are specific to caches and can only be applied to response messages. New Warning headers SHOULD be added after any existing Warning headers. A cache MUST NOT delete any Warning header that it received with a message. However, if a cache successfully validates a cache entry, it SHOULD remove any Warning headers previously attached to that entry except as specified for<p>specific Warning codes. It MUST then add any Warning headers received in the validating response. In other words, Warning headers are those that would be attached to the most recent relevant response.<p>When multiple Warning headers are attached to a response, the user agent ought to inform the user of as many of them as possible, in the order that they appear in the response. If it is not possible to inform the user of all of the warnings, the user agent SHOULD follow these heuristics:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre><td class="code"><pre><span class="line">- Warnings that appear early in the response take priority over</span><br><span class="line">  those appearing later in the response.</span><br><span class="line">- Warnings in the user&apos;s preferred character set take priority</span><br><span class="line">  over warnings in other character sets but with identical warn-</span><br><span class="line">  codes and warn-agents.</span><br></pre></table></figure><p>Systems that generate multiple Warning headers SHOULD order them with this user agent behavior in mind.<p>Requirements for the behavior of caches with respect to Warnings are stated in section 13.1.2.<p>This is a list of the currently-defined warn-codes, each with a recommended warn-text in English, and a description of its meaning.<p>110 Response is stale MUST be included whenever the returned response is stale.<p>111 Revalidation failed MUST be included if a cache returns a stale response because an attempt to revalidate the response failed, due to an inability to reach the server.<p>112 Disconnected operation SHOULD be included if the cache is intentionally disconnected from the rest of the network for a period of time.<p>113 Heuristic expiration MUST be included if the cache heuristically chose a freshness lifetime greater than 24 hours and the response’s age is greater than 24 hours.<p>199 Miscellaneous warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user.<p>214 Transformation applied MUST be added by an intermediate cache or proxy if it applies any transformation changing the content-coding (as specified in the Content-Encoding header) or media-type (as specified in the Content-Type header) of the response, or the entity-body of the response, unless this Warning code already appears in the response.<p>299 Miscellaneous persistent warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action.<p>If an implementation sends a message with one or more Warning headers whose version is HTTP/1.0 or lower, then the sender MUST include in each warning-value a warn-date that matches the date in the response.<p>If an implementation receives a message with a warning-value that includes a warn-date, and that warn-date is different from the Date value in the response, then that warning-value MUST be deleted from the message before storing, forwarding, or using it. (This prevents bad consequences of naive caching of Warning header fields.) If all of the warning-values are deleted for this reason, the Warning header MUST be deleted as well.<h3 id="14-47-WWW-Authenticate">14.47 WWW-Authenticate</h3><p>The WWW-Authenticate response-header field MUST be included in 401 (Unauthorized) response messages. The field value consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the Request-URI.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre><td class="code"><pre><span class="line">WWW-Authenticate  = &quot;WWW-Authenticate&quot; &quot;:&quot; 1#challenge</span><br></pre></table></figure><p>The HTTP access authentication process is described in “HTTP Authentication: Basic and Digest Access Authentication” [43]. User agents are advised to take special care in parsing the WWW- Authenticate field value as it might contain more than one challenge, or if more than one WWW-Authenticate header field is provided, the contents of a challenge itself can contain a comma-separated list of authentication parameters.</div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script type="text/javascript" src="https://code.jquery.com/jquery-1.7.1.min.js" integrity="sha256-iBcUE/x23aI6syuqF7EeT/+JFBxjPs5zeFJEXxumwb0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-sweetalert/1.0.1/sweetalert.min.js" integrity="sha256-JirYRqbf+qzfqVtEE4GETyHlAbiCpC005yBTa4rj6xg=" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-sweetalert/1.0.1/sweetalert.min.css" integrity="sha256-zuyRv+YsWwh1XR5tsrZ7VCfGqUmmPmqBjIvJgQWoSDo=" crossorigin="anonymous"><p><span>本文标题:</span>Header Field Definitions<p><span>文章作者:</span>kinboy<p><span>发布时间:</span>2018年07月02日 - 17:25:21<p><span>最后更新:</span>2019年07月15日 - 18:05:10<p><span>原始链接:</span><a href="/2018/07/02/HTTP Header Field Definitions/" title="Header Field Definitions">http://kinboyw.github.io/2018/07/02/HTTP Header Field Definitions/</a><span class="copy-path" title="点击复制文章链接"></span><p><span>许可协议:</span> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</div><script>var clipboard=new Clipboard(".fa-clipboard");clipboard.on("success",$(function(){$(".fa-clipboard").click(function(){swal({title:"",text:"复制成功",html:!1,timer:500,showConfirmButton:!1})})}))</script></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">------ Passage Ending ------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author:</strong> kinboy<li class="post-copyright-link"><strong>Post link:</strong> <a href="http://kinboyw.github.io/2018/07/02/HTTP Header Field Definitions/" title="Header Field Definitions">http://kinboyw.github.io/2018/07/02/HTTP Header Field Definitions/</a><li class="post-copyright-license"><strong>Copyright Notice:</strong> All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/HTTP-Header/" rel="tag"># HTTP Header</a> <a href="/tags/Protocol/" rel="tag"># Protocol</a></div><div class="post-nav"><div class="post-nav-prev post-nav-item"><a href="/2018/07/11/ike-scan扫描服务端的ike加密算法/" rel="prev" title="ike-scan扫描ipsec vpn服务端ike加密算法">ike-scan扫描ipsec vpn服务端ike加密算法</a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents<li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="kinboy"><p class="site-author-name" itemprop="name">kinboy</div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">31</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">52</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate">RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/kinboyw" target="_blank" title="GitHub">GitHub</a></span><span class="links-of-author-item"><a href="mailto:kinboy9275@gmail.com" target="_blank" title="E-Mail"> E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-Header-Field-Definitions"><span class="nav-number">1.</span> <span class="nav-text">14 Header Field Definitions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-Accept"><span class="nav-number">1.1.</span> <span class="nav-text">14.1 Accept</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-Accept-Charset"><span class="nav-number">1.2.</span> <span class="nav-text">14.2 Accept-Charset</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-Accept-Encoding"><span class="nav-number">1.3.</span> <span class="nav-text">14.3 Accept-Encoding</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-Accept-Language"><span class="nav-number">1.4.</span> <span class="nav-text">14.4 Accept-Language</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-Accept-Ranges"><span class="nav-number">1.5.</span> <span class="nav-text">14.5 Accept-Ranges</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-Age"><span class="nav-number">1.6.</span> <span class="nav-text">14.6 Age</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-7-Allow"><span class="nav-number">1.7.</span> <span class="nav-text">14.7 Allow</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-8-Authorization"><span class="nav-number">1.8.</span> <span class="nav-text">14.8 Authorization</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-9-Cache-Control"><span class="nav-number">1.9.</span> <span class="nav-text">14.9 Cache-Control</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-9-1-What-is-Cacheable"><span class="nav-number">1.10.</span> <span class="nav-text">14.9.1 What is Cacheable</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-9-2-What-May-be-Stored-by-Caches"><span class="nav-number">1.11.</span> <span class="nav-text">14.9.2 What May be Stored by Caches</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-9-3-Modifications-of-the-Basic-Expiration-Mechanism"><span class="nav-number">1.12.</span> <span class="nav-text">14.9.3 Modifications of the Basic Expiration Mechanism</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-9-4-Cache-Revalidation-and-Reload-Controls"><span class="nav-number">1.13.</span> <span class="nav-text">14.9.4 Cache Revalidation and Reload Controls</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-9-5-No-Transform-Directive"><span class="nav-number">1.14.</span> <span class="nav-text">14.9.5 No-Transform Directive</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-9-6-Cache-Control-Extensions"><span class="nav-number">1.15.</span> <span class="nav-text">14.9.6 Cache Control Extensions</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-10-Connection"><span class="nav-number">1.16.</span> <span class="nav-text">14.10 Connection</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-11-Content-Encoding"><span class="nav-number">1.17.</span> <span class="nav-text">14.11 Content-Encoding</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-12-Content-Language"><span class="nav-number">1.18.</span> <span class="nav-text">14.12 Content-Language</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-13-Content-Length"><span class="nav-number">1.19.</span> <span class="nav-text">14.13 Content-Length</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-14-Content-Location"><span class="nav-number">1.20.</span> <span class="nav-text">14.14 Content-Location</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-15-Content-MD5"><span class="nav-number">1.21.</span> <span class="nav-text">14.15 Content-MD5</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-16-Content-Range"><span class="nav-number">1.22.</span> <span class="nav-text">14.16 Content-Range</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-17-Content-Type"><span class="nav-number">1.23.</span> <span class="nav-text">14.17 Content-Type</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-18-Date"><span class="nav-number">1.24.</span> <span class="nav-text">14.18 Date</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-18-1-Clockless-Origin-Server-Operation"><span class="nav-number">1.25.</span> <span class="nav-text">14.18.1 Clockless Origin Server Operation</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-19-ETag"><span class="nav-number">1.26.</span> <span class="nav-text">14.19 ETag</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-20-Expect"><span class="nav-number">1.27.</span> <span class="nav-text">14.20 Expect</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-21-Expires"><span class="nav-number">1.28.</span> <span class="nav-text">14.21 Expires</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-22-From"><span class="nav-number">1.29.</span> <span class="nav-text">14.22 From</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-23-Host"><span class="nav-number">1.30.</span> <span class="nav-text">14.23 Host</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-24-If-Match"><span class="nav-number">1.31.</span> <span class="nav-text">14.24 If-Match</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-25-If-Modified-Since"><span class="nav-number">1.32.</span> <span class="nav-text">14.25 If-Modified-Since</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-26-If-None-Match"><span class="nav-number">1.33.</span> <span class="nav-text">14.26 If-None-Match</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-27-If-Range"><span class="nav-number">1.34.</span> <span class="nav-text">14.27 If-Range</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-28-If-Unmodified-Since"><span class="nav-number">1.35.</span> <span class="nav-text">14.28 If-Unmodified-Since</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-29-Last-Modified"><span class="nav-number">1.36.</span> <span class="nav-text">14.29 Last-Modified</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-30-Location"><span class="nav-number">1.37.</span> <span class="nav-text">14.30 Location</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-31-Max-Forwards"><span class="nav-number">1.38.</span> <span class="nav-text">14.31 Max-Forwards</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-32-Pragma"><span class="nav-number">1.39.</span> <span class="nav-text">14.32 Pragma</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-33-Proxy-Authenticate"><span class="nav-number">1.40.</span> <span class="nav-text">14.33 Proxy-Authenticate</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-34-Proxy-Authorization"><span class="nav-number">1.41.</span> <span class="nav-text">14.34 Proxy-Authorization</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-35-Range"><span class="nav-number">1.42.</span> <span class="nav-text">14.35 Range</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-35-1-Byte-Ranges"><span class="nav-number">1.43.</span> <span class="nav-text">14.35.1 Byte Ranges</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-35-2-Range-Retrieval-Requests"><span class="nav-number">1.44.</span> <span class="nav-text">14.35.2 Range Retrieval Requests</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-36-Referer"><span class="nav-number">1.45.</span> <span class="nav-text">14.36 Referer</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-37-Retry-After"><span class="nav-number">1.46.</span> <span class="nav-text">14.37 Retry-After</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-38-Server"><span class="nav-number">1.47.</span> <span class="nav-text">14.38 Server</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-39-TE"><span class="nav-number">1.48.</span> <span class="nav-text">14.39 TE</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-40-Trailer"><span class="nav-number">1.49.</span> <span class="nav-text">14.40 Trailer</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-41-Transfer-Encoding"><span class="nav-number">1.50.</span> <span class="nav-text">14.41 Transfer-Encoding</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-42-Upgrade"><span class="nav-number">1.51.</span> <span class="nav-text">14.42 Upgrade</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-43-User-Agent"><span class="nav-number">1.52.</span> <span class="nav-text">14.43 User-Agent</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-44-Vary"><span class="nav-number">1.53.</span> <span class="nav-text">14.44 Vary</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-45-Via"><span class="nav-number">1.54.</span> <span class="nav-text">14.45 Via</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-46-Warning"><span class="nav-number">1.55.</span> <span class="nav-text">14.46 Warning</span></a><li class="nav-item nav-level-3"><a class="nav-link" href="#14-47-WWW-Authenticate"><span class="nav-number">1.56.</span> <span class="nav-text">14.47 WWW-Authenticate</span></a></ol></ol></div></div></section><div class="back-to-top"><span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love"></span> <span class="author" itemprop="copyrightHolder">kinboy</span><br><img src="/images/beian.png"> <span style="width:300px;margin:0 auto;padding:20px 0"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42011102002861" style="display:inline-block;text-decoration:none;height:20px;line-height:20px"><img src style="float:left"><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#939393">鄂公网安备 42011102002861号</p></a></span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/three/three.min.js"></script><script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script id="dsq-count-scr" src="https://kinboy-wang.disqus.com/count.js" async></script><script type="text/javascript">var disqus_config=function(){this.page.url="http://kinboyw.github.io/2018/07/02/HTTP Header Field Definitions/",this.page.identifier="2018/07/02/HTTP Header Field Definitions/",this.page.title="Header Field Definitions"},d=document,s=d.createElement("script");s.src="https://kinboy-wang.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script type="text/javascript">// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script>